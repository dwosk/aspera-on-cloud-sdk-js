/* tslint:disable */
/* eslint-disable */
/**
 * Aspera on Cloud API
 * A REST API for the Files, Packages, and Admin applications in Asperaâ€™s premier SaaS offering, [Aspera on Cloud](https://www.ibm.com/cloud/aspera) (AoC). With the Aspera on Cloud API, you can quickly and reliably send and share files of any size across a hybrid cloud environment. Using AoC, organizations can store and readily access files and folders in multiple cloud-based and on-premises storage systems.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AppMembershipsParams
 */
export interface AppMembershipsParams {
    /**
     * The ID of the member that this membership belongs to.
     * @type {string}
     * @memberof AppMembershipsParams
     */
    member_id?: string;
    /**
     * 
     * @type {MemberType}
     * @memberof AppMembershipsParams
     */
    member_type?: MemberType;
}
/**
 * 
 * @export
 * @interface AppMembershipsResponse
 */
export interface AppMembershipsResponse {
    /**
     * Name of the app that the membership belongs to.
     * @type {string}
     * @memberof AppMembershipsResponse
     */
    app_name?: string;
    /**
     * 
     * @type {AppType}
     * @memberof AppMembershipsResponse
     */
    app_type?: AppType;
    /**
     * ID of the app membership.
     * @type {string}
     * @memberof AppMembershipsResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AppMembershipsResponse
     */
    member_id?: string;
    /**
     * 
     * @type {MemberType1}
     * @memberof AppMembershipsResponse
     */
    member_type?: MemberType1;
}
/**
 * Type of app that the membership belongs to.
 * @export
 * @enum {string}
 */
export enum AppType {
    Activity = 'activity',
    Automation = 'automation'
}

/**
 * 
 * @export
 * @interface AppsNewPackagesRequest
 */
export interface AppsNewPackagesRequest {
    /**
     * Make all sent packages accessible to all workspace members
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    allow_access_sent?: boolean;
    /**
     * Allow senders to set package expiration
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    allow_package_level_expirations?: boolean;
    /**
     * Managers can send packages to the entire workspace. The parameter can_users_send_to_workspace must be set to true.
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    can_managers_send_to_workspace?: boolean;
    /**
     * Users can send packages to the entire workspace
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    can_users_send_to_workspace?: boolean;
    /**
     * Eligible external users allowlist is enabled. To set allowed users, groups, or emails, send a POST request to /admin/app_collaborators.
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    collaboration_whitelist_enabled?: boolean;
    /**
     * Allow external users with any email. The user does not have to be a specific registered user or group.
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    collaboration_with_emails_allowed?: boolean;
    /**
     * Delete this package after the specified time (in seconds)
     * @type {number}
     * @memberof AppsNewPackagesRequest
     */
    content_retention_duration?: number;
    /**
     * Automatically apply encryption at rest to all packages
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    default_ear_setting?: boolean;
    /**
     * Delete recalled packages after the specified time (in seconds)
     * @type {number}
     * @memberof AppsNewPackagesRequest
     */
    draft_expiration_duration?: number;
    /**
     * The Packages app is enabled
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    enabled?: boolean;
    /**
     * Require external users to log in in order to receive packages
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    external_package_authentication_required?: boolean;
    /**
     * Users can send packages to external users (outside of AoC)
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    external_package_sending_allowed?: boolean;
    /**
     * Managers can send packages to external users (outside of AoC). The parameter external_package_sending_allowed must be set to true.
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    external_package_sending_allowed_by_managers?: boolean;
    /**
     * External senders must enter their email and name before sendng a package
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    external_sender_email_and_name_required?: boolean;
    /**
     * The Packages app corresponding to the current app_id inherits the global app settings. The setting applies to the Packages app only at the workspace level.
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    inherit_organization_app_settings?: boolean;
    /**
     * Show the download count within package details
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    package_download_counts_enabled?: boolean;
    /**
     * Automatically create a JSON file within all packages. This file includes shared inbox metadata and additional package information.
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    package_sidecar_enabled?: boolean;
    /**
     * Users can create personalized URLs for public and authenticated links. The parameter url_shortening_enabled must be set to true.
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    personalized_urls_enabled?: boolean;
    /**
     * Any user can request packages by sharing submission links.
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    public_invites_allowed?: boolean;
    /**
     * Managers can request packages by sharing public submission links. The parameter public_invites_allowed must be set to true.
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    public_invites_allowed_by_managers?: boolean;
    /**
     * If the workspace is attached to a node with a watermarking profile, you can enable package level watermarking.
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    watermarking_allowed?: boolean;
    /**
     * Require watermarking on all sent packages. The parameter watermarking_allowed must be set to true.
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    watermarking_required?: boolean;
    /**
     * Users can shorten URLs from their standard length, to something like aspera.pub/2da3xfa
     * @type {boolean}
     * @memberof AppsNewPackagesRequest
     */
    url_shortening_enabled?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum AsperaAppType {
    Activity = 'activity',
    Automation = 'automation'
}

/**
 * Asset for a file
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * File path, relative to the docroot
     * @type {string}
     * @memberof Asset
     */
    source: string;
    /**
     * Watermark identifier for the file
     * @type {number}
     * @memberof Asset
     */
    job_id: number;
    /**
     * If true, this file is watermarked
     * @type {boolean}
     * @memberof Asset
     */
    watermark: boolean;
}
/**
 * For Aspera Transfer Service nodes, this field defines which type of storage is used.
 * @export
 * @enum {string}
 */
export enum AtsStorageType {
    AwsS3 = 'aws_s3',
    Azure = 'azure',
    AzureFiles = 'azure-files',
    AzureSas = 'azure_sas',
    GoogleGcs = 'google-gcs',
    IbmS3 = 'ibm-s3',
    SoftlayerSwift = 'softlayer_swift'
}

/**
 * 
 * @export
 * @interface Capability
 */
export interface Capability {
    /**
     * 
     * @type {string}
     * @memberof Capability
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Capability
     */
    value?: boolean;
}
/**
 * 
 * @export
 * @interface ClientAccessKeysParams
 */
export interface ClientAccessKeysParams {
    /**
     * Id of the client access key.
     * @type {string}
     * @memberof ClientAccessKeysParams
     */
    id: string;
    /**
     * The name of the client access key
     * @type {string}
     * @memberof ClientAccessKeysParams
     */
    name?: string;
    /**
     * Id of the node to which the client access key belongs.
     * @type {string}
     * @memberof ClientAccessKeysParams
     */
    node_id: string;
    /**
     * 
     * @type {string}
     * @memberof ClientAccessKeysParams
     */
    permission_id?: string;
    /**
     * The id of the directory that this access key grants permissions for.
     * @type {string}
     * @memberof ClientAccessKeysParams
     */
    root_file_id: string;
}
/**
 * 
 * @export
 * @interface ClientAccessKeysRequest
 */
export interface ClientAccessKeysRequest {
    /**
     * The name of the client access key
     * @type {string}
     * @memberof ClientAccessKeysRequest
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface ClientAccessKeysResponse
 */
export interface ClientAccessKeysResponse {
    /**
     * The date at which the client access key was created.
     * @type {string}
     * @memberof ClientAccessKeysResponse
     */
    created_at?: string;
    /**
     * Id of the client access key.
     * @type {string}
     * @memberof ClientAccessKeysResponse
     */
    id?: string;
    /**
     * The name of the client access key
     * @type {string}
     * @memberof ClientAccessKeysResponse
     */
    name?: string;
    /**
     * Id of the node to which the client access key belongs.
     * @type {string}
     * @memberof ClientAccessKeysResponse
     */
    node_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientAccessKeysResponse
     */
    permission_id?: string;
    /**
     * The id of the directory that this access key grants permissions for.
     * @type {string}
     * @memberof ClientAccessKeysResponse
     */
    root_file_id?: string;
    /**
     * The date at which the client access key was last updated.
     * @type {string}
     * @memberof ClientAccessKeysResponse
     */
    updated_at?: string;
    /**
     * Id of the workspace to which the client access key belongs.
     * @type {string}
     * @memberof ClientAccessKeysResponse
     */
    workspace_id?: string;
}
/**
 * 
 * @export
 * @interface ClientAuthorizationsParams
 */
export interface ClientAuthorizationsParams {
    /**
     * The ID of the client.
     * @type {string}
     * @memberof ClientAuthorizationsParams
     */
    client_id: string;
    /**
     * The ID of the entity that can be authorized.
     * @type {number}
     * @memberof ClientAuthorizationsParams
     */
    entity_id: number;
    /**
     * 
     * @type {EntityType}
     * @memberof ClientAuthorizationsParams
     */
    entity_type: EntityType;
}
/**
 * 
 * @export
 * @interface ClientAuthorizationsResponse
 */
export interface ClientAuthorizationsResponse {
    /**
     * The ID of the client.
     * @type {string}
     * @memberof ClientAuthorizationsResponse
     */
    client_id?: string;
    /**
     * The timestamp of authorization.
     * @type {string}
     * @memberof ClientAuthorizationsResponse
     */
    created_at?: string;
    /**
     * The ID of the entity that can be authorized.
     * @type {number}
     * @memberof ClientAuthorizationsResponse
     */
    entity_id?: number;
    /**
     * 
     * @type {EntityType}
     * @memberof ClientAuthorizationsResponse
     */
    entity_type?: EntityType;
    /**
     * The client ID
     * @type {string}
     * @memberof ClientAuthorizationsResponse
     */
    id?: string;
    /**
     * The timestamp of the most recent update.
     * @type {string}
     * @memberof ClientAuthorizationsResponse
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ClientsParams
 */
export interface ClientsParams {
    /**
     * If you use the JWT grant type (jwt_grant_enabled=true), whether or not to allow users of this client who are AoC administrators to retrieve admin-scoped node access tokens. Such a token provides the user with admin privileges on the node itself. Admin permissions required. Defaults to false.
     * @type {boolean}
     * @memberof ClientsParams
     */
    admin_node_token_retrieval_enabled?: boolean;
    /**
     * Use with browser-based authorization. When users log in using the client app via a browser, prompt them to explicitly allow access to AoC features. Admin permissions required. Defaults to true.
     * @type {boolean}
     * @memberof ClientsParams
     */
    explicit_authorization_required?: boolean;
    /**
     * Allow the client to authenticate using the JSON web token method. The JWT grant allows the users of the client to log in without having to use a web browser. Admin permissions required.
     * @type {boolean}
     * @memberof ClientsParams
     */
    jwt_grant_enabled?: boolean;
    /**
     * The name of the client app to register. Admin permissions required. POST: required. PUT: not required.
     * @type {string}
     * @memberof ClientsParams
     */
    name: string;
    /**
     * The allowable list of origins for the client. An origin is the URI or protocol-host-port of the client app initial login page, from which the user must arrive to the authentication flow. Array of JSON origins (strings) Admin permissions required. Separate multiple origins with commas. Maximum characters: 65535.
     * @type {Array<string>}
     * @memberof ClientsParams
     */
    origins?: Array<string>;
    /**
     * RSA public key in PEM format. The corresponding private key can be used to generate a JWT assertion for any user in the organization. Admin permissions required. Maximum characters: 65535.
     * @type {string}
     * @memberof ClientsParams
     */
    public_key?: string;
    /**
     * The allowable list of redirect URIs for the client. A redirect URI (protocol-host-port) is an absolute URI invoked after the authentication flow to return the user to the client app. Array of JSON redirect URIs (strings) Admin permissions required. Separate multiple redirect URIs with commas. Maximum characters: 65535.
     * @type {Array<string>}
     * @memberof ClientsParams
     */
    redirect_uris?: Array<string>;
    /**
     * Enable creation of a specific list of users and groups eligible to receive an access token. To create the whitelist, see /client_authorizations. Admin permissions required. Pertains to JWT grants. Default is false.
     * @type {boolean}
     * @memberof ClientsParams
     */
    whitelist_enabled?: boolean;
}
/**
 * 
 * @export
 * @interface ClientsResponse
 */
export interface ClientsResponse {
    /**
     * If you use the JWT grant type (jwt_grant_enabled=true), whether or not to allow users of this client who are AoC administrators to retrieve admin-scoped node access tokens. Such a token provides the user with admin privileges on the node itself. Default is false.
     * @type {boolean}
     * @memberof ClientsResponse
     */
    admin_node_token_retrieval_enabled?: boolean;
    /**
     * Whether or not to allow the client app to obtain an access token directly from the authorization endpoint, without contacting the token endpoint or authenticating the client.
     * @type {boolean}
     * @memberof ClientsResponse
     */
    allow_implicit_grant?: boolean;
    /**
     * Timestamp of original creation of the client. Datetime.
     * @type {string}
     * @memberof ClientsResponse
     */
    created_at?: string;
    /**
     * ID of the user who created the client.
     * @type {string}
     * @memberof ClientsResponse
     */
    creator_id?: string;
    /**
     * Use with browser-based authorization. When users log in using the client app via a browser, prompt them to explicitly allow access to AoC features. Default is true.
     * @type {boolean}
     * @memberof ClientsResponse
     */
    explicit_authorization_required?: boolean;
    /**
     * ID of the client app.
     * @type {string}
     * @memberof ClientsResponse
     */
    id?: string;
    /**
     * Allow the client to authenticate using the JSON web token method. The JWT grant allows the users of the client to log in without having to use a web browser. Default is false.
     * @type {boolean}
     * @memberof ClientsResponse
     */
    jwt_grant_enabled?: boolean;
    /**
     * Name assigned to the client. Maximum length: 255 characters.
     * @type {string}
     * @memberof ClientsResponse
     */
    name?: string;
    /**
     * ID of the AoC organization to which the client belongs.
     * @type {string}
     * @memberof ClientsResponse
     */
    organization_id?: string;
    /**
     * The allowable list of origins for the client. An origin is the URI or protocol-host-port of the client app initial login page, from which the user must arrive to the authentication flow. Separate multiple origins with commas. Maximum characters: 65535. Array of json origins (strings).
     * @type {Array<string>}
     * @memberof ClientsResponse
     */
    origins?: Array<string>;
    /**
     * The public portion of the RSA key pair. Maximum characters: 65535.
     * @type {string}
     * @memberof ClientsResponse
     */
    public_key?: string;
    /**
     * The allowable list of redirect URIs for this client. A redirect URI, or protocol-host-port, is an absolute URI invoked after the authentication flow to return the user to the client app. Separate multiple redirect URIs with commas. Maximum characters: 65535.
     * @type {Array<string>}
     * @memberof ClientsResponse
     */
    redirect_uris?: Array<string>;
    /**
     * The secret associated with this client.
     * @type {string}
     * @memberof ClientsResponse
     */
    secret?: string;
    /**
     * Timestamp of last modification to the client. datetime
     * @type {string}
     * @memberof ClientsResponse
     */
    updated_at?: string;
    /**
     * Enable creation of a specific list of users and groups eligible to receive an access token. Pertains to JWT grants. Default is false. See /client_authorizations.
     * @type {boolean}
     * @memberof ClientsResponse
     */
    whitelist_enabled?: boolean;
}
/**
 * 
 * @export
 * @interface Config
 */
export interface Config {
    /**
     * Endpoint of IBM Key Protect instance
     * @type {string}
     * @memberof Config
     */
    endpoint?: string;
    /**
     * Instance ID of IBM Key Protect instance
     * @type {string}
     * @memberof Config
     */
    instance_id?: string;
    /**
     * Root key ID that acts as the master encryption key
     * @type {string}
     * @memberof Config
     */
    root_key_id?: string;
    /**
     * API key for IBM Key Protect instance
     * @type {string}
     * @memberof Config
     */
    api_key?: string;
}
/**
 * 
 * @export
 * @interface Config1
 */
export interface Config1 {
    /**
     * Endpoint of your IBM Key Protect instance
     * @type {string}
     * @memberof Config1
     */
    endpoint?: string;
    /**
     * Instance ID of your IBM Key Protect instance
     * @type {string}
     * @memberof Config1
     */
    instance_id?: string;
    /**
     * Root key ID that acts as the master encryption key
     * @type {string}
     * @memberof Config1
     */
    root_key_id?: string;
}
/**
 * 
 * @export
 * @interface Config3
 */
export interface Config3 {
    /**
     * API key used by the Aspera KMS integration service
     * @type {string}
     * @memberof Config3
     */
    api_key?: string;
}
/**
 * 
 * @export
 * @interface DropboxMembershipsParams
 */
export interface DropboxMembershipsParams {
    /**
     * Indicates whether this member can receive packages.
     * @type {boolean}
     * @memberof DropboxMembershipsParams
     */
    can_receive_packages?: boolean;
    /**
     * Indicates whether this member can submit packages.
     * @type {boolean}
     * @memberof DropboxMembershipsParams
     */
    can_submit_packages?: boolean;
    /**
     * ID of the dropbox to which this membership belongs.
     * @type {string}
     * @memberof DropboxMembershipsParams
     */
    dropbox_id: string;
    /**
     * Indicates whether this member is a dropbox manager.
     * @type {boolean}
     * @memberof DropboxMembershipsParams
     */
    manager?: boolean;
    /**
     * ID of the member to which this membership belongs.
     * @type {string}
     * @memberof DropboxMembershipsParams
     */
    member_id: string;
    /**
     * 
     * @type {MemberType2}
     * @memberof DropboxMembershipsParams
     */
    member_type?: MemberType2;
    /**
     * Defines the time at which the dropbox will be closed to submission for a specific dropbox member. If null, the dropbox has no submission deadline.
     * @type {string}
     * @memberof DropboxMembershipsParams
     */
    submit_expires_at?: string;
}
/**
 * 
 * @export
 * @interface DropboxMembershipsResponse
 */
export interface DropboxMembershipsResponse {
    /**
     * Indicates whether this member can receive packages.
     * @type {boolean}
     * @memberof DropboxMembershipsResponse
     */
    can_receive_packages?: boolean;
    /**
     * Indicates whether this member can submit packages.
     * @type {boolean}
     * @memberof DropboxMembershipsResponse
     */
    can_submit_packages?: boolean;
    /**
     * ID of the user who created this membership.
     * @type {string}
     * @memberof DropboxMembershipsResponse
     */
    creator_id?: string;
    /**
     * ID of the dropbox to which this membership belongs.
     * @type {string}
     * @memberof DropboxMembershipsResponse
     */
    dropbox_id?: string;
    /**
     * ID of this dropbox membership.
     * @type {string}
     * @memberof DropboxMembershipsResponse
     */
    id?: string;
    /**
     * Indicates whether this member is a dropbox manager.
     * @type {boolean}
     * @memberof DropboxMembershipsResponse
     */
    manager?: boolean;
    /**
     * ID of the member to which this membership belongs.
     * @type {string}
     * @memberof DropboxMembershipsResponse
     */
    member_id?: string;
    /**
     * 
     * @type {MemberType2}
     * @memberof DropboxMembershipsResponse
     */
    member_type?: MemberType2;
    /**
     * Indicates whether the member may make a submission to the dropbox.
     * @type {boolean}
     * @memberof DropboxMembershipsResponse
     */
    submit_expired?: boolean;
    /**
     * Defines the time at which the dropbox will be closed to submission for a specific dropbox member. If null, the dropbox has no submission deadline.
     * @type {string}
     * @memberof DropboxMembershipsResponse
     */
    submit_expires_at?: string;
    /**
     * The ID of the workspace to which this dropbox membership belongs.
     * @type {string}
     * @memberof DropboxMembershipsResponse
     */
    workspace_id?: string;
}
/**
 * 
 * @export
 * @interface DropboxMembershipsUpdateParams
 */
export interface DropboxMembershipsUpdateParams {
    /**
     * Indicates whether this member can receive packages.
     * @type {boolean}
     * @memberof DropboxMembershipsUpdateParams
     */
    can_receive_packages?: boolean;
    /**
     * Indicates whether this member can submit packages.
     * @type {boolean}
     * @memberof DropboxMembershipsUpdateParams
     */
    can_submit_packages?: boolean;
    /**
     * Indicates whether this member is a dropbox manager.
     * @type {boolean}
     * @memberof DropboxMembershipsUpdateParams
     */
    manager?: boolean;
    /**
     * Defines the time at which the dropbox will be closed to submission for a specific dropbox member. If null, the dropbox has no submission deadline.
     * @type {string}
     * @memberof DropboxMembershipsUpdateParams
     */
    submit_expires_at?: string;
}
/**
 * 
 * @export
 * @interface DropboxNotificationRecipient
 */
export interface DropboxNotificationRecipient {
    /**
     * For type = user | group, id denotes the integer ID of that user or group (e.g., \"123\"). For type = email, id denotes the email address of the intended addressee (e.g., \"email@foo.co\").
     * @type {string}
     * @memberof DropboxNotificationRecipient
     */
    id?: string;
    /**
     * 
     * @type {Type}
     * @memberof DropboxNotificationRecipient
     */
    type?: Type;
}
/**
 * 
 * @export
 * @interface DropboxesParams
 */
export interface DropboxesParams {
    /**
     * Configure a time-based expiration policy for packages in this shared inbox by setting this parameter to a non-null value. Once the transfer completes, a timer begins. After the duration configured for this parameter, package contents are deleted (the package record is maintained and includes details about the sender, recipients, contents, and transfer). If null, this shared inbox inherits the content_retention_duration settings of its workspace. Valid values: null - 10 years. Units: seconds. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {number}
     * @memberof DropboxesParams
     */
    content_retention_duration?: number;
    /**
     * For a package sent to a shared inbox, this parameter determines whether notifications are sent to all package addressees or to a user-defined list of addressees for the shared inbox (see dropbox_notification_recipients). Defaults to false. Valid values: true to send notifications to a user-defined list or false to send notifications to all package addressees. POST: Admin or Manager permission required. PUT: Admin or Manager permission required. RESPONSE: Admin scope.
     * @type {boolean}
     * @memberof DropboxesParams
     */
    custom_notification_list_enabled?: boolean;
    /**
     * Configure a download-based expiration policy for packages in this shared inbox by setting this parameter to a non-null value. Once all package recipients have downloaded the entire package, a timer begins. After the duration configured by this parameter has passed, package contents are deleted (the package record is maintained and includes details about the sender, recipients, contents, and transfer). If null, this shared inbox inherits the delete_package_content_after_download_duration settings of its workspace. Valid values: null - 10 years. Units: seconds. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {number}
     * @memberof DropboxesParams
     */
    delete_package_content_after_download_duration?: number;
    /**
     * A description for the shared inbox. POST: Admin or Manager permission required. PUT: Admin or Manager permission required. RESPONSE: Admin scope.
     * @type {string}
     * @memberof DropboxesParams
     */
    description: string;
    /**
     * Configure a time-based expiration policy for draft packages in this shared inbox by setting this parameter to a non-null value. When a package is saved as a draft, a timer begins. After the duration configured for this parameter, draft package contents are deleted. If this parameter is null, it defaults to the workspace setting. To set a time-based expiration policy for non-draft packages, see content_retention_duration. Units: seconds. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {number}
     * @memberof DropboxesParams
     */
    draft_expiration_duration?: number;
    /**
     * With custom_notification_list_enabled = true, this parameter defines a list of addressees who should receive notifications regarding packages addressed to this shared inbox. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {Array<DropboxNotificationRecipient>}
     * @memberof DropboxesParams
     */
    dropbox_notification_recipients?: Array<DropboxNotificationRecipient>;
    /**
     * 
     * @type {EmailNotificationSettings}
     * @memberof DropboxesParams
     */
    email_notification_settings?: EmailNotificationSettings;
    /**
     * If inherit_email_templates is set to false, you can enable or disable the ability to configure email templates specifically for users outside this shared inbox. When this parameter is set to false, external recipients receive the same email notification messages that users in the shared inbox receive. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {boolean}
     * @memberof DropboxesParams
     */
    enable_external_email_templates?: boolean;
    /**
     * The image data for the shared inbox logo encoded as a string. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {string}
     * @memberof DropboxesParams
     */
    image_data?: string;
    /**
     * The image type of the shared inbox logo. For example, image/png or image/jpg. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {string}
     * @memberof DropboxesParams
     */
    image_type?: string;
    /**
     * Inherit the email notification settings configured at the workspace level. POST Admin or Manager permission required. PUT Admin or Manager permission required.
     * @type {boolean}
     * @memberof DropboxesParams
     */
    inherit_email_notification_settings?: boolean;
    /**
     * Inherit the email templates configured at the workspace level. If false, you can configure email template settings for this shared inbox. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {boolean}
     * @memberof DropboxesParams
     */
    inherit_email_templates?: boolean;
    /**
     * Inherit the content_retention_duration settings configured at the workspace level. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {boolean}
     * @memberof DropboxesParams
     */
    inherit_workspace_expiration_settings?: boolean;
    /**
     * User-defined instructions for potential shared inbox submissions. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {string}
     * @memberof DropboxesParams
     */
    instructions: string;
    /**
     * A metadata schema is used to present a form to a user when the user is submitting content to a dropbox. It is an array with \"Field\" objects, and each Field object defines one field that the user can fill out when submitting content to a dropbox. Note that the order of the fields in the metadata schema array will be the order in which they are shown to the user.
     * @type {Array<Metadatum>}
     * @memberof DropboxesParams
     */
    metadata_schema?: Array<Metadatum>;
    /**
     * Shared inbox name. A query parameter for the GET method. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {string}
     * @memberof DropboxesParams
     */
    name: string;
    /**
     * Defines illegal characters and/or max length for the name and message fields for package submissions to this shared inbox. Defaults to an empty array ([]). POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {Array<PackageNameAndMessageValidationSchema>}
     * @memberof DropboxesParams
     */
    package_name_and_message_validation_schema?: Array<PackageNameAndMessageValidationSchema>;
    /**
     * Enable members of this shared inbox to configure personalized URLs to send when inviting people to submit packages. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {boolean}
     * @memberof DropboxesParams
     */
    personalized_urls_enabled?: boolean;
    /**
     * ID of the workspace to which this shared inbox belongs. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {string}
     * @memberof DropboxesParams
     */
    workspace_id: string;
}
/**
 * 
 * @export
 * @interface DropboxesResponse
 */
export interface DropboxesResponse {
    /**
     * Configure a time-based expiration policy for packages in this shared inbox by setting this parameter to a non-null value. Once the transfer completes, a timer begins. After the duration configured for this parameter, package contents are deleted (the package record is maintained and includes details about the sender, recipients, contents, and transfer). If null, this shared inbox inherits the content_retention_duration settings of its workspace. Valid values: null - 10 years. Units: seconds. POST: Admin or Manager permission required. PUT: Admin or Manager permission required. Write only.
     * @type {number}
     * @memberof DropboxesResponse
     */
    content_retention_duration?: number;
    /**
     * For a package sent to a shared inbox, this configuration determines whether notifications are sent to all package addressees or a user-defined list of addressees for the shared inbox (see dropbox_notification_recipients). Defaults to false. Valid values: true to send notifications to a user-defined list or false to send notifications to all package addressees. POST: Admin or Manager permission required. PUT: Admin or Manager permission required. RESPONSE: Admin scope.
     * @type {boolean}
     * @memberof DropboxesResponse
     */
    custom_notification_list_enabled?: boolean;
    /**
     * Configure a download-based expiration policy for packages in this shared inbox by setting this parameter to a non-null value. Once all package recipients have downloaded the entire package, a timer begins. After the duration configured by this parameter has passed, package contents are deleted (the package record is maintained and includes details about the sender, recipients, contents, and transfer). If null, this shared inbox inherits the delete_package_content_after_download_duration settings of its workspace. Valid values: null - 10 years. Units: seconds. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {number}
     * @memberof DropboxesResponse
     */
    delete_package_content_after_download_duration?: number;
    /**
     * A description for the shared inbox. POST: Admin or Manager permission required. PUT: Admin or Manager permission required. RESPONSE: Admin scope.
     * @type {string}
     * @memberof DropboxesResponse
     */
    description?: string;
    /**
     * Configure a time-based expiration policy for draft packages in this shared inbox by setting this parameter to a non-null value. When a package is saved as a draft, a timer begins. After the duration configured for this parameter, draft package contents are deleted. If this parameter is null, it defaults to the workspace setting. To set a time-based expiration policy for non-draft packages, see content_retention_duration. Units: seconds. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {number}
     * @memberof DropboxesResponse
     */
    draft_expiration_duration?: number;
    /**
     * With custom_notification_list_enabled = true, this parameter defines a list of addressees who should receive notifications regarding packages addressed to this shared inbox. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {Array<DropboxNotificationRecipient>}
     * @memberof DropboxesResponse
     */
    dropbox_notification_recipients?: Array<DropboxNotificationRecipient>;
    /**
     * Amount of time in seconds it takes for packages in this shared inbox to be deleted once their transfers complete. If null, packages will not be deleted on a timer. Read-only.
     * @type {number}
     * @memberof DropboxesResponse
     */
    effective_content_retention_duration?: number;
    /**
     * Amount of time in seconds it takes a package in this shared inbox to be deleted once all recipients have downloaded the entire package. If null, packages will not be deleted on a timer. Read-only.
     * @type {number}
     * @memberof DropboxesResponse
     */
    effective_delete_package_content_after_download_duration?: number;
    /**
     * 
     * @type {EmailNotificationSettings}
     * @memberof DropboxesResponse
     */
    email_notification_settings?: EmailNotificationSettings;
    /**
     * If inherit_email_templates is set to false, you can enable or disable the ability to configure email templates specifically for users outside this shared inbox. When this parameter is set to false, external recipients receive the same email notification messages that users in the shared inbox receive. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {boolean}
     * @memberof DropboxesResponse
     */
    enable_external_email_templates?: boolean;
    /**
     * The ID of the shared inbox. Read-only.
     * @type {string}
     * @memberof DropboxesResponse
     */
    id?: string;
    /**
     * The URL of the shared inbox logo image. Read-only.
     * @type {string}
     * @memberof DropboxesResponse
     */
    image_url?: string;
    /**
     * Inherit the email notification settings configured at the workspace level. POST Admin or Manager permission required. PUT Admin or Manager permission required.
     * @type {boolean}
     * @memberof DropboxesResponse
     */
    inherit_email_notification_settings?: boolean;
    /**
     * Inherit the email templates configured at the workspace level. If false, you can configure email template settings for this shared inbox. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {boolean}
     * @memberof DropboxesResponse
     */
    inherit_email_templates?: boolean;
    /**
     * Inherit the content_retention_duration settings configured at the workspace level. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {boolean}
     * @memberof DropboxesResponse
     */
    inherit_workspace_expiration_settings?: boolean;
    /**
     * User defined instructions for potential shared inbox submissions. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {string}
     * @memberof DropboxesResponse
     */
    instructions?: string;
    /**
     * A metadata schema is used to present a form to a user when the user is submitting content to a dropbox. It is an array with \"Field\" objects, and each Field object defines one field that the user can fill out when submitting content to a dropbox. Note that the order of the fields in the metadata schema array will be the order in which they are shown to the user.
     * @type {Array<Metadatum>}
     * @memberof DropboxesResponse
     */
    metadata_schema?: Array<Metadatum>;
    /**
     * shared inbox name. A query parameter for the GET method. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {string}
     * @memberof DropboxesResponse
     */
    name?: string;
    /**
     * Defines illegal characters and/or max length for the name and message fields for package submissions to this shared inbox. Defaults to an empty array ([]). POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {Array<PackageNameAndMessageValidationSchema>}
     * @memberof DropboxesResponse
     */
    package_name_and_message_validation_schema?: Array<PackageNameAndMessageValidationSchema>;
    /**
     * Enable members of this shared inbox to configure personalized URLs to send when inviting people to submit packages. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {boolean}
     * @memberof DropboxesResponse
     */
    personalized_urls_enabled?: boolean;
    /**
     * ID of the group that all shared inbox recipients belong to. Read-only.
     * @type {string}
     * @memberof DropboxesResponse
     */
    recipients_group_id?: string;
    /**
     * ID of the group that all senders to the shared inbox belong to. Read-only.
     * @type {string}
     * @memberof DropboxesResponse
     */
    senders_group_id?: string;
    /**
     * ID of the workspace to which this shared inbox belongs. POST: Admin or Manager permission required. PUT: Admin or Manager permission required.
     * @type {string}
     * @memberof DropboxesResponse
     */
    workspace_id?: string;
}
/**
 * 
 * @export
 * @interface EmailNotificationSettings
 */
export interface EmailNotificationSettings {
    /**
     * An email notification setting; refer to email_notification_settings. Notify users who receive an invitation to send a package to a dropbox. Refer also to public_invites_allowed(_by_managers).
     * @type {boolean}
     * @memberof EmailNotificationSettings
     */
    dropbox_invitation?: boolean;
    /**
     * An email notification setting; refer to email_notification_settings. Notify users who are recipients of a shared file. Refer also to public_links_allowed(_by_managers).
     * @type {boolean}
     * @memberof EmailNotificationSettings
     */
    file_shared?: boolean;
    /**
     * An email notification setting; refer to email_notification_settings. Notifiy users who receive an invitation to send a package to an individual (as opposed to sending to a dropbox; see dropbox_invitation). Refer also to external_package_sending_allowed(_by_managers).
     * @type {boolean}
     * @memberof EmailNotificationSettings
     */
    invitation_to_send_to_me?: boolean;
    /**
     * An email notification setting; refer to email_notification_settings. Notify package recipients when a package is deleted (senders or administrators can delete packages).
     * @type {boolean}
     * @memberof EmailNotificationSettings
     */
    package_contents_deleted?: boolean;
    /**
     * An email notification setting; refer to email_notification_settings. Notify package sender when recipients have downloaded the package.
     * @type {boolean}
     * @memberof EmailNotificationSettings
     */
    package_downloaded?: boolean;
    /**
     * An email notification setting; refer to email_notification_settings. Notify package recipients when package contents are deleted according to configured package expiration policy (see also delete_package_content_after_download_duration and content_retention_duration).
     * @type {boolean}
     * @memberof EmailNotificationSettings
     */
    package_expired?: boolean;
    /**
     * An email notification setting; refer to email_notification_settings. Notify package sender when a package transfer has failed.
     * @type {boolean}
     * @memberof EmailNotificationSettings
     */
    package_failed?: boolean;
    /**
     * An email notification setting; refer to email_notification_settings. Notify package recipients when a package has been recalled by the sender. When a package is recalled, the recipient cannot browse or download package contents until the sender resends the package.
     * @type {boolean}
     * @memberof EmailNotificationSettings
     */
    package_recalled?: boolean;
    /**
     * An email notification setting; refer to email_notification_settings. Notify package recipients when they have received a package and the package is available.
     * @type {boolean}
     * @memberof EmailNotificationSettings
     */
    package_received?: boolean;
    /**
     * An email notification setting; refer to email_notification_settings. Notify package recipients when a recalled package has been resent. The package will be available to the recipient when the transfer completes; at that point the recipient receives the package_received notification.
     * @type {boolean}
     * @memberof EmailNotificationSettings
     */
    package_resent?: boolean;
    /**
     * An email notification setting; refer to email_notification_settings. Notify package sender that the package was successfully sent. The package will be available to the recipient when the transfer completes; at that point the recipient receives the package_received notification.
     * @type {boolean}
     * @memberof EmailNotificationSettings
     */
    package_sent?: boolean;
    /**
     * An email notification setting; refer to email_notification_settings. Notify package sender that the package was successfully uploaded to the transfer server.
     * @type {boolean}
     * @memberof EmailNotificationSettings
     */
    package_uploaded?: boolean;
}
/**
 * The type of entity who can be authorized. Default is user.
 * @export
 * @enum {string}
 */
export enum EntityType {
    User = 'user',
    Group = 'group'
}

/**
 * 
 * @export
 * @interface ErrorContainer
 */
export interface ErrorContainer {
    /**
     * 
     * @type {Array<ErrorModel>}
     * @memberof ErrorContainer
     */
    errors: Array<ErrorModel>;
    /**
     * 
     * @type {string}
     * @memberof ErrorContainer
     */
    trace?: string;
    /**
     * 
     * @type {number}
     * @memberof ErrorContainer
     */
    status_code?: number;
}
/**
 * 
 * @export
 * @interface ErrorModel
 */
export interface ErrorModel {
    /**
     * 
     * @type {string}
     * @memberof ErrorModel
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorModel
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorModel
     */
    more_info?: string;
    /**
     * 
     * @type {ErrorTarget}
     * @memberof ErrorModel
     */
    target?: ErrorTarget;
}
/**
 * 
 * @export
 * @interface ErrorTarget
 */
export interface ErrorTarget {
    /**
     * 
     * @type {Target}
     * @memberof ErrorTarget
     */
    target: Target;
    /**
     * 
     * @type {string}
     * @memberof ErrorTarget
     */
    name: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum FieldName {
    Name = 'package_name',
    Message = 'package_message'
}

/**
 * 
 * @export
 * @interface Identity
 */
export interface Identity {
    /**
     * Irdeto identity ID
     * @type {number}
     * @memberof Identity
     */
    identity_id: number;
    /**
     * Digital watermarking endpoint
     * @type {string}
     * @memberof Identity
     */
    dwm_endpoint: string;
    /**
     * Tenant ID associated with the watermarking profile
     * @type {string}
     * @memberof Identity
     */
    tenant_id: string;
    /**
     * User ID
     * @type {string}
     * @memberof Identity
     */
    user_id: string;
    /**
     * 
     * @type {User}
     * @memberof Identity
     */
    user: User;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Include {
    AvailableNodes = 'available_nodes'
}

/**
 * The type of the field.
 * @export
 * @enum {string}
 */
export enum InputType {
    SingleText = 'single-text',
    Date = 'date',
    Textbox = 'textbox',
    SingleDropdown = 'single-dropdown',
    MultipleCheckbox = 'multiple-checkbox'
}

/**
 * Update parameters for the KMS profile
 * @export
 * @interface IntegrationsKmsProfilesRequest
 */
export interface IntegrationsKmsProfilesRequest {
    /**
     * Name of the KMS profile
     * @type {string}
     * @memberof IntegrationsKmsProfilesRequest
     */
    name?: string;
    /**
     * 
     * @type {Config3}
     * @memberof IntegrationsKmsProfilesRequest
     */
    config?: Config3;
}
/**
 * 
 * @export
 * @interface IntegrationsWatermarkIdentitiesResponse
 */
export interface IntegrationsWatermarkIdentitiesResponse {
    /**
     * 
     * @type {Array<Identity>}
     * @memberof IntegrationsWatermarkIdentitiesResponse
     */
    identities: Array<Identity>;
}
/**
 * Aspera on Cloud (AoC) Node
 * @export
 * @interface KmsAocNode1
 */
export interface KmsAocNode1 {
    /**
     * ID of AoC transfer node
     * @type {string}
     * @memberof KmsAocNode1
     */
    node_id: string;
    /**
     * Name of AoC transfer node
     * @type {string}
     * @memberof KmsAocNode1
     */
    name: string;
    /**
     * ID for your organization in AoC
     * @type {string}
     * @memberof KmsAocNode1
     */
    organization_id: string;
    /**
     * ID of key management service profile
     * @type {string}
     * @memberof KmsAocNode1
     */
    profile_id: string;
    /**
     * Access key of AoC node
     * @type {string}
     * @memberof KmsAocNode1
     */
    access_key: string;
}
/**
 * Key management service profile (with API key included)
 * @export
 * @interface KmsProfileRequest
 */
export interface KmsProfileRequest {
    /**
     * Name of key management service profile
     * @type {string}
     * @memberof KmsProfileRequest
     */
    name: string;
    /**
     * ID of provider for key management service instance
     * @type {string}
     * @memberof KmsProfileRequest
     */
    provider: string;
    /**
     * 
     * @type {Config}
     * @memberof KmsProfileRequest
     */
    config: Config;
}
/**
 * KMS profile (does not include the API key)
 * @export
 * @interface KmsProfileResponse
 */
export interface KmsProfileResponse {
    /**
     * ID of key management service profile
     * @type {string}
     * @memberof KmsProfileResponse
     */
    id: string;
    /**
     * Name of key management service profile
     * @type {string}
     * @memberof KmsProfileResponse
     */
    name: string;
    /**
     * ID of key management service provider
     * @type {string}
     * @memberof KmsProfileResponse
     */
    provider: string;
    /**
     * 
     * @type {Config1}
     * @memberof KmsProfileResponse
     */
    config: Config1;
}
/**
 * KMS profile respone for DELETE (does not include the API key)
 * @export
 * @interface KmsProfileResponseDelete
 */
export interface KmsProfileResponseDelete {
    /**
     * ID of key management service profile
     * @type {string}
     * @memberof KmsProfileResponseDelete
     */
    id: string;
    /**
     * Name of key management service profile
     * @type {string}
     * @memberof KmsProfileResponseDelete
     */
    name: string;
    /**
     * ID of key management service provider
     * @type {string}
     * @memberof KmsProfileResponseDelete
     */
    provider: string;
    /**
     * 
     * @type {Config1}
     * @memberof KmsProfileResponseDelete
     */
    config: Config1;
    /**
     * Time when the KMS profile was created, in UTC format
     * @type {string}
     * @memberof KmsProfileResponseDelete
     */
    created_at: string;
    /**
     * Time when the KMS profile was updated, in UTC format
     * @type {string}
     * @memberof KmsProfileResponseDelete
     */
    updated_at: string;
}
/**
 * The type of member that this membership belongs to.
 * @export
 * @enum {string}
 */
export enum MemberType {
    User = 'user',
    Group = 'group'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum MemberType1 {
    User = 'user',
    Group = 'group'
}

/**
 * Describes the kind of member to which this membership belongs.
 * @export
 * @enum {string}
 */
export enum MemberType2 {
    User = 'user',
    Group = 'group'
}

/**
 * 
 * @export
 * @interface Metadatum
 */
export interface Metadatum {
    /**
     * The value(s) to be configured by the sender. Required for single-dropdown and multiple-checkbox.
     * @type {Array<string>}
     * @memberof Metadatum
     */
    choices?: Array<string>;
    /**
     * Sets the singular default value for each input_type except multiple-checkbox. In the case of multiple-checkbox, a default value is set for each checkbox.
     * @type {Array<string>}
     * @memberof Metadatum
     */
    default_values?: Array<string>;
    /**
     * Defines all disallowed characters for string fields.
     * @type {string}
     * @memberof Metadatum
     */
    illegal_characters?: string;
    /**
     * 
     * @type {InputType}
     * @memberof Metadatum
     */
    input_type: InputType;
    /**
     * For string fields defines the maximum number of characters allowed.
     * @type {string}
     * @memberof Metadatum
     */
    max_length?: string;
    /**
     * The label of the metadata field.
     * @type {string}
     * @memberof Metadatum
     */
    name: string;
    /**
     * Denotes a field as required.
     * @type {boolean}
     * @memberof Metadatum
     */
    required?: boolean;
}
/**
 * 
 * @export
 * @interface NodesParams
 */
export interface NodesParams {
    /**
     * Access keys are used for authorization when AoC makes a request via the Node API. Each transfer node must have a unique access key.
     * @type {string}
     * @memberof NodesParams
     */
    access_key?: string;
    /**
     * Indicates that access_key is a key for an Aspera Transfer Service node. Defaults to false. Used on POST only.
     * @type {boolean}
     * @memberof NodesParams
     */
    ats_access_key?: boolean;
    /**
     * 
     * @type {AtsStorageType}
     * @memberof NodesParams
     */
    ats_storage_type?: AtsStorageType;
    /**
     * References the configuration policy to which a transfer node belongs.
     * @type {number}
     * @memberof NodesParams
     */
    configuration_policy_id?: number;
    /**
     * KMS Profile id returned on creating a KMS Profile
     * @type {string}
     * @memberof NodesParams
     */
    kms_profile_id?: string;
    /**
     * User-defined identifier for the transfer node. Each transfer node must have a unique name.
     * @type {string}
     * @memberof NodesParams
     */
    name?: string;
    /**
     * References the network configuration policy to which a transfer node belongs.
     * @type {number}
     * @memberof NodesParams
     */
    network_policy_id?: number;
    /**
     * If your node has SSH capabilities, used for verifying SSH connections.
     * @type {string}
     * @memberof NodesParams
     */
    ssh_fingerprint?: string;
    /**
     * 
     * @type {Status}
     * @memberof NodesParams
     */
    status?: Status;
    /**
     * Specifies the URL where the transfer node is located. Necessary for AoC to make requests via the Node API.
     * @type {string}
     * @memberof NodesParams
     */
    url?: string;
    /**
     * Describes node secure socket layer usage. Defaults to true.
     * @type {boolean}
     * @memberof NodesParams
     */
    use_ssl?: boolean;
    /**
     * Specifies whether or not node must verify SSL certificate. Defaults to true.
     * @type {boolean}
     * @memberof NodesParams
     */
    verify_ssl_certificate?: boolean;
    /**
     * The ID of the watermarking profile that is associated with this node
     * @type {string}
     * @memberof NodesParams
     */
    watermark_profile_id?: string;
}
/**
 * 
 * @export
 * @interface NodesResponse
 */
export interface NodesResponse {
    /**
     * KMS Profile id returned on creating a KMS Profile
     * @type {string}
     * @memberof NodesResponse
     */
    kms_profile_id?: string;
    /**
     * Host portion of node URL.
     * @type {string}
     * @memberof NodesResponse
     */
    host?: string;
    /**
     * Access keys are used for authorization when AoC makes a request via the Node API. Each transfer node must have a unique access key.
     * @type {string}
     * @memberof NodesResponse
     */
    access_key?: string;
    /**
     * Indicates that access_key is a key for an Aspera Transfer Service node. Defaults to false. Used on POST only.
     * @type {boolean}
     * @memberof NodesResponse
     */
    ats_access_key?: boolean;
    /**
     * 
     * @type {AtsStorageType}
     * @memberof NodesResponse
     */
    ats_storage_type?: AtsStorageType;
    /**
     * 
     * @type {Array<Capability>}
     * @memberof NodesResponse
     */
    capabilities?: Array<Capability>;
    /**
     * References the configuration policy to which a node belongs.
     * @type {number}
     * @memberof NodesResponse
     */
    configuration_policy_id?: number;
    /**
     * Short message describing the nature of the most recent transfer node error.
     * @type {string}
     * @memberof NodesResponse
     */
    error_message?: string;
    /**
     * Datetime. Indicates time of most recent error.
     * @type {string}
     * @memberof NodesResponse
     */
    error_time?: string;
    /**
     * User-defined identifier for the transfer node. Each transfer node must have a unique name.
     * @type {string}
     * @memberof NodesResponse
     */
    name?: string;
    /**
     * References the network configuration policy to which a transfer node belongs.
     * @type {number}
     * @memberof NodesResponse
     */
    network_policy_id?: number;
    /**
     * Path portion of the transfer node URL.
     * @type {string}
     * @memberof NodesResponse
     */
    path?: string;
    /**
     * Port portion of the transfer node URL.
     * @type {number}
     * @memberof NodesResponse
     */
    port?: number;
    /**
     * 
     * @type {Array<Setting>}
     * @memberof NodesResponse
     */
    settings?: Array<Setting>;
    /**
     * If your node has SSH capabilities, used for verifying SSH connections.
     * @type {string}
     * @memberof NodesResponse
     */
    ssh_fingerprint?: string;
    /**
     * 
     * @type {Status}
     * @memberof NodesResponse
     */
    status?: Status;
    /**
     * Specifies the URL where the transfer node is located. Necessary for AoC to make requests via the Node API.
     * @type {string}
     * @memberof NodesResponse
     */
    url?: string;
    /**
     * Describes node secure socket layer usage. Defaults to true.
     * @type {boolean}
     * @memberof NodesResponse
     */
    use_ssl?: boolean;
    /**
     * Specifies whether or not node must verify SSL certificate. Defaults to true.
     * @type {boolean}
     * @memberof NodesResponse
     */
    verify_ssl_certificate?: boolean;
    /**
     * 
     * @type {WatermarkProfileResponse}
     * @memberof NodesResponse
     */
    watermark_profile?: WatermarkProfileResponse;
    /**
     * Watermarking profile ID associated with this node
     * @type {string}
     * @memberof NodesResponse
     */
    watermark_profile_id?: string;
}
/**
 * 
 * @export
 * @interface OrganizationsParams
 */
export interface OrganizationsParams {
    /**
     * Data for the image to be displayed on the organization sign-in page. The data must be binary and have a maximum size of 4MB. Returned only when image_data is included in the request (e.g., include%5B%5D=image_data).
     * @type {string}
     * @memberof OrganizationsParams
     */
    background_image_data?: string;
    /**
     * The file type of the background image.
     * @type {string}
     * @memberof OrganizationsParams
     */
    background_image_type?: string;
    /**
     * The number of login failures allowed before the user is required to change passwords. Valid values: 2 - 10. Requires organization admin permission to view or update.
     * @type {number}
     * @memberof OrganizationsParams
     */
    consecutive_login_failures_limit?: number;
    /**
     * Indicates the default encryption-at-rest setting for your organization. Defaults to false. Requires organization admin permission to view or update.
     * @type {boolean}
     * @memberof OrganizationsParams
     */
    default_ear_setting?: boolean;
    /**
     * Text to be added as the footer in email notifications sent for your organization. Must have organization admin permission to view or update.
     * @type {string}
     * @memberof OrganizationsParams
     */
    email_footer?: string;
    /**
     * 
     * @type {EmailNotificationSettings}
     * @memberof OrganizationsParams
     */
    email_notification_settings?: EmailNotificationSettings;
    /**
     * Indicates whether the organization has external email templates enabled. Requires organization admin permission to view or update.
     * @type {boolean}
     * @memberof OrganizationsParams
     */
    enable_external_email_templates?: boolean;
    /**
     * The number of password changes that must occur before a password can be reused. Valid values are 1 - 12, or null to disable. Requires organization admin permission to view or update.
     * @type {number}
     * @memberof OrganizationsParams
     */
    enforce_password_history_count?: number;
    /**
     * Customer-configurable endpoint that can receive reporting for AoC events. Requires organization admin permission to view or update.
     * @type {string}
     * @memberof OrganizationsParams
     */
    event_reporting_uri?: string;
    /**
     * If Google OAuth is enabled, this parameter can be used to define a list of domains for email addresses that are not allowed to log into your  organization. This parameter is mutually exclusive with google_included_domains. Requires organization admin permission to view or update.
     * @type {Array<string>}
     * @memberof OrganizationsParams
     */
    google_excluded_domains?: Array<string>;
    /**
     * If Google OAuth is enabled, this parameter can be used to define a list of domains for email addresses that are allowed to log into your organization. This parameter is mutually exclusive with google_excluded_domains. Requires organization admin permission to view or update.
     * @type {Array<string>}
     * @memberof OrganizationsParams
     */
    google_included_domains?: Array<string>;
    /**
     * Indicates whether users can be authenticated through Google OAuth for your organization. Requires organization admin permission to view or update.
     * @type {boolean}
     * @memberof OrganizationsParams
     */
    google_oauth_included?: boolean;
    /**
     * Indicates whether this organization is using customized email templates. Requires organization admin permission to view or update.
     * @type {boolean}
     * @memberof OrganizationsParams
     */
    inherit_email_templates?: boolean;
    /**
     * Text for the email notification that is sent to new users when they are invited to join your organization. Requires organization admin permission to view or update.
     * @type {string}
     * @memberof OrganizationsParams
     */
    invitation_message?: string;
    /**
     * If local OAuth is enabled, this parameter can be used to define a list of domains for email addresses that are not allowed to log into your organization. This parameter is mutually exclusive with local_included_domains. Requires organization admin permission to view or update.
     * @type {Array<string>}
     * @memberof OrganizationsParams
     */
    local_excluded_domains?: Array<string>;
    /**
     * If local OAuth is enabled, this parameter can be used to define a list of domains for email addresses that are allowed to log into your organization. This parameter is mutually exclusive with local_excluded_domains. Requires organization admin permission to view or update.
     * @type {Array<string>}
     * @memberof OrganizationsParams
     */
    local_included_domains?: Array<string>;
    /**
     * Customized text that will appear on the local login button. Requires organization admin permission to view or update.
     * @type {string}
     * @memberof OrganizationsParams
     */
    local_login_button_text?: string;
    /**
     * Indicates whether users can be authenticated through local OAuth for your organization. Requires organization admin permission to view or update.
     * @type {boolean}
     * @memberof OrganizationsParams
     */
    local_oauth_enabled?: boolean;
    /**
     * Data for the image to be used as the organization logo. The data must be binary and have a maximum size of 512KB. This field is included only when the query string includes \"include%5B%5D=image_data\".
     * @type {string}
     * @memberof OrganizationsParams
     */
    logo_image_data?: string;
    /**
     * The data type of the provided logo image.
     * @type {string}
     * @memberof OrganizationsParams
     */
    logo_image_type?: string;
    /**
     * Defines the minimum age for a password before it can be reset. Units: seconds. Valid values: 15 minutes to 1 year (900 - 31536000), or null to disable. Requires organization admin permission to view or update.
     * @type {number}
     * @memberof OrganizationsParams
     */
    minimum_password_age?: number;
    /**
     * The minimum length for passwords for users in your organization. Valid values: 8 - 100. Requires organization admin permission to view or update.
     * @type {number}
     * @memberof OrganizationsParams
     */
    minimum_password_length?: number;
    /**
     * The name of your organization.
     * @type {string}
     * @memberof OrganizationsParams
     */
    name?: string;
    /**
     * How long a password reset link is valid, when it is sent as part of an invitation to a new user. Units: seconds. Valid values: 1 hour - 1 week (3600 - 604800), or null to disable. Requires organization admin permission to view or update.
     * @type {number}
     * @memberof OrganizationsParams
     */
    new_user_password_reset_token_duration?: number;
    /**
     * Denotes the amount of time that a transfer node access token is valid. Must be at least as long as access_token_duration. Units: seconds. Valid values: 1 hour - 14 days (3600 - 1209600). Requires organization admin permission to view or update.
     * @type {number}
     * @memberof OrganizationsParams
     */
    node_token_duration?: number;
    /**
     * If true, workspace managers can see all organization contacts. Otherwise, workspace managers can only see the contacts for their workspace. Requires organization admin permission to view or update.
     * @type {boolean}
     * @memberof OrganizationsParams
     */
    organization_contacts_visible_to_managers?: boolean;
    /**
     * How often a password change is required. Units: seconds. Valid values: 15 days to 1 year (129600 - 31536000) or null to disable. Requires organization admin permission to view or update.
     * @type {number}
     * @memberof OrganizationsParams
     */
    password_expiration_interval?: number;
    /**
     * How long the password reset link is good for. Units: seconds. Valid values: 1 hour - 1 week (3600 - 604800), or null to disable. Requires organization admin permission to view or update.
     * @type {number}
     * @memberof OrganizationsParams
     */
    password_reset_token_duration?: number;
    /**
     * Indicates whether to require users to set \"strong\" passwords. A \"strong\" password contains at least three of the following: 1. A lowercase letter 2. An uppercase letter 3. A non-word  character (!, @, #, etc.) 4. A number. Requires organization admin permission to view or update.
     * @type {boolean}
     * @memberof OrganizationsParams
     */
    require_strong_passwords?: boolean;
    /**
     * How long a user can be inactive before their session is terminated and their access token is invalidated. Units: seconds. Valid values: 1 hour - 1 week (3600 - 604800), or null to disable.
     * @type {number}
     * @memberof OrganizationsParams
     */
    session_duration?: number;
    /**
     * Message displayed to users on sign-in.
     * @type {string}
     * @memberof OrganizationsParams
     */
    sign_on_message?: string;
    /**
     * When creating a workspace, node_id is required, but the client app can choose to use this value as a default. This is set automatically to the first transfer node created in your organization. Requires organization admin permission to view or update.
     * @type {string}
     * @memberof OrganizationsParams
     */
    workspace_container_node_id?: string;
}
/**
 * 
 * @export
 * @interface OrganizationsResponse
 */
export interface OrganizationsResponse {
    /**
     * How long an access token is valid. Units: seconds. Valid values: 3600 - 86400 (1 - 24 hours). Viewable by organization admin only.
     * @type {number}
     * @memberof OrganizationsResponse
     */
    access_token_duration?: number;
    /**
     * The maximum amount of time that can pass in which an access token can be refreshed. Units: seconds. Valid values: 3600 - 1209600 (1 hour - 14 days), or null to disable access token refreshing. Viewable by organization admin only.
     * @type {number}
     * @memberof OrganizationsResponse
     */
    access_token_refresh_duration?: number;
    /**
     * Data for the image to be displayed on the organization sign-in page. The data must be binary and have a maximum size of 4MB. Returned only when image_data is included in the request (e.g. include%5B%5D=image_data).
     * @type {string}
     * @memberof OrganizationsResponse
     */
    background_image_data?: string;
    /**
     * The file type of the background image.
     * @type {string}
     * @memberof OrganizationsResponse
     */
    background_image_type?: string;
    /**
     * The URL at which the background image is stored.
     * @type {string}
     * @memberof OrganizationsResponse
     */
    background_image_url?: string;
    /**
     * The number of login failures allowed before the user is required to change passwords. Valid values: 2 - 10. Requires organization admin permission to view or update.
     * @type {number}
     * @memberof OrganizationsResponse
     */
    consecutive_login_failures_limit?: number;
    /**
     * The time at which the organization was created. Viewable by organization admin only.
     * @type {string}
     * @memberof OrganizationsResponse
     */
    created_at?: string;
    /**
     * Indicates the default encryption-at-rest setting for your organization. Defaults to false. Requires organization admin permission to view or update.
     * @type {boolean}
     * @memberof OrganizationsResponse
     */
    default_ear_setting?: boolean;
    /**
     * The default text that appears on the local login button. Viewable by organization admin only.
     * @type {string}
     * @memberof OrganizationsResponse
     */
    default_local_login_button_text?: string;
    /**
     * Text to be added as the footer in email notifications sent for your organization. Must have organization admin permission to view or update.
     * @type {string}
     * @memberof OrganizationsResponse
     */
    email_footer?: string;
    /**
     * 
     * @type {EmailNotificationSettings}
     * @memberof OrganizationsResponse
     */
    email_notification_settings?: EmailNotificationSettings;
    /**
     * Indicates whether the organization has external email templates enabled. Requires organization admin permission to view or update.
     * @type {boolean}
     * @memberof OrganizationsResponse
     */
    enable_external_email_templates?: boolean;
    /**
     * The number of password changes that must occur before a password can be reused. Valid values are 1 - 12, or null to disable. Requires organization admin permission to view or update.
     * @type {number}
     * @memberof OrganizationsResponse
     */
    enforce_password_history_count?: number;
    /**
     * Customer-configurable endpoint that can receive reporting for AoC events. Requires organization admin permission to view or update.
     * @type {string}
     * @memberof OrganizationsResponse
     */
    event_reporting_uri?: string;
    /**
     * If Google OAuth is enabled, this parameter can be used to define a list of domains for email addresses that are not allowed to log into your  organization. This parameter is mutually exclusive with google_included_domains. Requires organization admin permission to view or update.
     * @type {Array<string>}
     * @memberof OrganizationsResponse
     */
    google_excluded_domains?: Array<string>;
    /**
     * If Google OAuth is enabled, this parameter can be used to define a list of domains for email addresses that are allowed to log into your organization. This parameter is mutually exclusive with google_excluded_domains. Requires organization admin permission to view or update.
     * @type {Array<string>}
     * @memberof OrganizationsResponse
     */
    google_included_domains?: Array<string>;
    /**
     * Indicates whether users can be authenticated through Google OAuth for your organization. Requires organization admin permission to view or update.
     * @type {boolean}
     * @memberof OrganizationsResponse
     */
    google_oauth_included?: boolean;
    /**
     * The ID of your organization. Read-only.
     * @type {string}
     * @memberof OrganizationsResponse
     */
    id?: string;
    /**
     * Indicates whether this organization is using customized email templates. Requires organization admin permission to view or update.
     * @type {boolean}
     * @memberof OrganizationsResponse
     */
    inherit_email_templates?: boolean;
    /**
     * Text for the email notification that is sent to new users when they are invited to join your organization. Requires organization admin permission to view or update.
     * @type {string}
     * @memberof OrganizationsResponse
     */
    invitation_message?: string;
    /**
     * If local OAuth is enabled, this parameter can be used to define a list of domains for email addresses that are not allowed to log into your organization. This parameter is mutually exclusive with local_included_domains. Requires organization admin permission to view or update.
     * @type {Array<string>}
     * @memberof OrganizationsResponse
     */
    local_excluded_domains?: Array<string>;
    /**
     * If local OAuth is enabled, this parameter can be used to define a list of domains for email addresses that are allowed to log into your organization. This parameter is mutually exclusive with local_excluded_domains. Requires organization admin permission to view or update.
     * @type {Array<string>}
     * @memberof OrganizationsResponse
     */
    local_included_domains?: Array<string>;
    /**
     * Customized text that will appear on the local login button. Requires organization admin permission to view or update.
     * @type {string}
     * @memberof OrganizationsResponse
     */
    local_login_button_text?: string;
    /**
     * Indicates whether users can be authenticated through local OAuth for your organization. Requires organization admin permission to view or update.
     * @type {boolean}
     * @memberof OrganizationsResponse
     */
    local_oauth_enabled?: boolean;
    /**
     * Data for the image to be used as organization logo. The data must be binary and have a maximum size of 512KB. This field is included only when the query string includes \"include%5B%5D=image_data\".
     * @type {string}
     * @memberof OrganizationsResponse
     */
    logo_image_data?: string;
    /**
     * The data type of the provided logo image.
     * @type {string}
     * @memberof OrganizationsResponse
     */
    logo_image_type?: string;
    /**
     * The URL at which your logo image is stored. Read-only.
     * @type {string}
     * @memberof OrganizationsResponse
     */
    logo_image_url?: string;
    /**
     * Defines the minimum age for a password before it can be reset. Units: seconds. Valid values: 15 minutes to 1 year (900 - 31536000), or null to disable. Requires organization admin permission to view or update.
     * @type {number}
     * @memberof OrganizationsResponse
     */
    minimum_password_age?: number;
    /**
     * The minimum length for passwords for users in your organization. Valid values: 8 - 100. Requires organization admin permission to view or update.
     * @type {number}
     * @memberof OrganizationsResponse
     */
    minimum_password_length?: number;
    /**
     * The name of your organization.
     * @type {string}
     * @memberof OrganizationsResponse
     */
    name?: string;
    /**
     * How long a password reset link is valid, when it is sent as part of an invitation to a new user. Units: seconds. Valid values: 1 hour - 1 week (3600 - 604800), or null to disable. Requires organization admin permission to view or update.
     * @type {number}
     * @memberof OrganizationsResponse
     */
    new_user_password_reset_token_duration?: number;
    /**
     * Denotes the amount of time that a transfer node access token is valid. Must be at least as long as access_token_duration. Units: seconds. Valid values: 1 hour - 14 days (3600 - 1209600). Requires organization admin permission to view or update.
     * @type {number}
     * @memberof OrganizationsResponse
     */
    node_token_duration?: number;
    /**
     * RSA public key used to verify OAuth tokens for this org. Requires organization admin permission to view. Read-only.
     * @type {string}
     * @memberof OrganizationsResponse
     */
    oauth_token_verification_key?: string;
    /**
     * If true, workspace managers can see all organization contacts. Otherwise, workspace managers can see only the contacts for their workspace. Requires organization admin permission to view or update.
     * @type {boolean}
     * @memberof OrganizationsResponse
     */
    organization_contacts_visible_to_managers?: boolean;
    /**
     * How often a password change is required. Units: seconds. Valid values: 15 days to 1 year (129600 - 31536000), or null to disable. Requires organization admin permission to view or update.
     * @type {number}
     * @memberof OrganizationsResponse
     */
    password_expiration_interval?: number;
    /**
     * How long the password reset link is valid. Units: seconds. Valid values: 1 hour - 1 week (3600 - 604800), or null to disable. Requires organization admin permission to view or update.
     * @type {number}
     * @memberof OrganizationsResponse
     */
    password_reset_token_duration?: number;
    /**
     * Indicates whether to require users to set \"strong\" passwords. A \"strong\" password contains at least three of the following: 1. A lowercase letter 2. An uppercase letter 3. A non-word  character (!, @, #, etc.) 4. A number. Requires organization admin permission to view or update.
     * @type {boolean}
     * @memberof OrganizationsResponse
     */
    require_strong_passwords?: boolean;
    /**
     * How long a user can be inactive before their session is terminated and their access token is invalidated. Units: seconds. Valid values: 1 hour - 1 week (3600 - 604800), or null to disable.
     * @type {number}
     * @memberof OrganizationsResponse
     */
    session_duration?: number;
    /**
     * Message displayed to users on sign-in.
     * @type {string}
     * @memberof OrganizationsResponse
     */
    sign_on_message?: string;
    /**
     * The subdomain name for your organization. Read-only.
     * @type {string}
     * @memberof OrganizationsResponse
     */
    subdomain_name?: string;
    /**
     * The tier of your organization\'s Aspera on Cloud subscription. Can be any of \"paygo\", \"standard\", \"advanced\", or \"enterprise\". Read-only.
     * @type {string}
     * @memberof OrganizationsResponse
     */
    tier?: string;
    /**
     * For organizations on trial subscriptions, this denotes the time at which their subscription ends. Is null in all other cases. Read-only.
     * @type {string}
     * @memberof OrganizationsResponse
     */
    trial_expires_at?: string;
    /**
     * The URL ID for your organization. Read-only.
     * @type {string}
     * @memberof OrganizationsResponse
     */
    url_id?: string;
    /**
     * When creating a workspace, node_id is required, but the client app can choose to use this value as a default. This is set automatically to the first transfer node created in your organization. Requires organization admin permission to view or update.
     * @type {string}
     * @memberof OrganizationsResponse
     */
    workspace_container_node_id?: string;
}
/**
 * 
 * @export
 * @interface PackageNameAndMessageValidationSchema
 */
export interface PackageNameAndMessageValidationSchema {
    /**
     * 
     * @type {FieldName}
     * @memberof PackageNameAndMessageValidationSchema
     */
    field_name?: FieldName;
    /**
     * Defines all disallowed characters.
     * @type {string}
     * @memberof PackageNameAndMessageValidationSchema
     */
    illegal_characters?: string;
    /**
     * Defines the max length for the provided string.
     * @type {string}
     * @memberof PackageNameAndMessageValidationSchema
     */
    max_length?: string;
}
/**
 * Package transfer tag
 * @export
 * @interface PackageTransferTagResponse
 */
export interface PackageTransferTagResponse {
    /**
     * Watermarking provider
     * @type {string}
     * @memberof PackageTransferTagResponse
     */
    provider: string;
    /**
     * Identity in watermarking for the authenticated user
     * @type {number}
     * @memberof PackageTransferTagResponse
     */
    distributor_id: number;
    /**
     * List of assets
     * @type {Array<Asset>}
     * @memberof PackageTransferTagResponse
     */
    assets: Array<Asset>;
}
/**
 * 
 * @export
 * @interface PackagesParams
 */
export interface PackagesParams {
    /**
     * Whether or not this package has been archived by the user.
     * @type {boolean}
     * @memberof PackagesParams
     */
    archived?: boolean;
    /**
     * 
     * @type {SendersRecipientsObject}
     * @memberof PackagesParams
     */
    bcc_recipients?: SendersRecipientsObject;
    /**
     * When a time-based content expiration value is set for this package, the duration to retain packages contents. When this duration passes, the packages contents are deleted. Valid values are null to 10 years. Units are seconds.
     * @type {number}
     * @memberof PackagesParams
     */
    content_retention_duration?: number;
    /**
     * If \'delete_after_download\' is set to \'true\', this parameter configures an optional \'grace period\', during which the package contents will be retained even after all recipients have downloaded the package. The timer for this setting begins when all recipients have downloaded the package; when the timer expires, the package contents are deleted. Valid values are null - 10 years.  Units are seconds.
     * @type {number}
     * @memberof PackagesParams
     */
    delete_package_content_after_download_duration?: number;
    /**
     * 
     * @type {SendersRecipientsObject}
     * @memberof PackagesParams
     */
    download_notification_recipients?: SendersRecipientsObject;
    /**
     * Whether or not the package is in draft status.
     * @type {boolean}
     * @memberof PackagesParams
     */
    draft?: boolean;
    /**
     * Whether or not the package has encryption_at_rest applied.
     * @type {boolean}
     * @memberof PackagesParams
     */
    encryption_at_rest?: boolean;
    /**
     * The names of the items to include in this package; multiple names separated by commas. Maximum characters: 65535
     * @type {string}
     * @memberof PackagesParams
     */
    file_names?: string;
    /**
     * JSON object. Maximum characters: 65535
     * @type {object}
     * @memberof PackagesParams
     */
    metadata?: object;
    /**
     * Package name. Required for POST. Optional for PUT.
     * @type {string}
     * @memberof PackagesParams
     */
    name: string;
    /**
     * The sender\'s message to recipients to include with the package. Maximum characters: 65535.
     * @type {string}
     * @memberof PackagesParams
     */
    note?: string;
    /**
     * Whether or not the package was read.
     * @type {boolean}
     * @memberof PackagesParams
     */
    read?: boolean;
    /**
     * 
     * @type {SendersRecipientsObject}
     * @memberof PackagesParams
     */
    recipients?: SendersRecipientsObject;
    /**
     * Whether or not the package was sent.
     * @type {boolean}
     * @memberof PackagesParams
     */
    sent?: boolean;
    /**
     * Whether or not all the contents of this package originate from the same location (node, workstation, etc.). When the package recipient downloads a package with Encryption at Rest (EAR) applied by the sender, and all package contents are from the same source (for example, the sender\'s desktop; a specific remote server), AoC signals Aspera Connect to prompt the recipient to apply the passphrase created by the sender and decrypt package contents during the download operation. When package contents are from disparate sources, the recipient applies the password to individual files in the downloaded package when opening each file.
     * @type {boolean}
     * @memberof PackagesParams
     */
    single_source?: boolean;
    /**
     * The number of transfer sessions expected to bring all package contents to the node supporting the workspace in which the package is sent. The number corresponds to the number of discrete source locations of the designated package contents. For example, if the package includes 20 files and folders from 5 discrete sources, the number of transfers expected is 5.
     * @type {number}
     * @memberof PackagesParams
     */
    transfers_expected?: number;
    /**
     * 
     * @type {SendersRecipientsObject}
     * @memberof PackagesParams
     */
    upload_notification_recipients?: SendersRecipientsObject;
    /**
     * Set to true if the package is to be watermarked. Default is false.
     * @type {boolean}
     * @memberof PackagesParams
     */
    watermark?: boolean;
    /**
     * The ID of the workspace from which this package was sent. Required for POST. Optional for PUT.
     * @type {number}
     * @memberof PackagesParams
     */
    workspace_id: number;
}
/**
 * 
 * @export
 * @interface PackagesResponse
 */
export interface PackagesResponse {
    /**
     * The number of active downloads.
     * @type {number}
     * @memberof PackagesResponse
     */
    active_download_count?: number;
    /**
     * Whether or not this package has been archived by the user. If user_package only.
     * @type {boolean}
     * @memberof PackagesResponse
     */
    archived?: boolean;
    /**
     * Float. User Packages.
     * @type {number}
     * @memberof PackagesResponse
     */
    average_rate?: number;
    /**
     * Whether or not there is a BCC list. If user_package only.
     * @type {boolean}
     * @memberof PackagesResponse
     */
    bcc?: boolean;
    /**
     * 
     * @type {SendersRecipientsObject}
     * @memberof PackagesResponse
     */
    bcc_recipients?: SendersRecipientsObject;
    /**
     * How many bytes have been transferred.
     * @type {number}
     * @memberof PackagesResponse
     */
    bytes_transferred?: number;
    /**
     * Whether or not the package is fully available on the transfer node; when the package is complete, all transfers of the designated files and folders into the package have been successful and all designated files and folders are present on the node.
     * @type {boolean}
     * @memberof PackagesResponse
     */
    complete?: boolean;
    /**
     * The timestamp that indicates when the package is complete. Refer to \'complete\'.
     * @type {string}
     * @memberof PackagesResponse
     */
    completed_at?: string;
    /**
     * The time at which package content will expire according to configured expiration policies. Refer to \'content_retention_duration\' and to the related parameters \'delete_after_download\' and \'delete_package_content_after_download_duration\'.
     * @type {string}
     * @memberof PackagesResponse
     */
    content_expires_at?: string;
    /**
     * When a time-based content expiration value is set for this package, the duration to retain packages contents. When this duration passes, the packages contents are deleted. Valid values are null - 10 years. Units are seconds.
     * @type {number}
     * @memberof PackagesResponse
     */
    content_retention_duration?: number;
    /**
     * The file ID on the node that contains package contents.
     * @type {string}
     * @memberof PackagesResponse
     */
    contents_file_id?: string;
    /**
     * The timestamp for when this package was created.
     * @type {string}
     * @memberof PackagesResponse
     */
    created_at?: string;
    /**
     * Whether or not an expiration policy applies to this package, indicating that package contents will expire (be deleted) after all recipients have downloaded the package.
     * @type {boolean}
     * @memberof PackagesResponse
     */
    delete_after_download?: boolean;
    /**
     * If \'delete_after_download\' is set to \'true\', this parameter configures an optional \'grace period\', during which the package contents will be retained even after all recipients have downloaded the package. The timer for this setting begins when all recipients have downloaded the package; when the timer expires, the package contents are deleted. Valid values are null - 10 years. Units are seconds.
     * @type {number}
     * @memberof PackagesResponse
     */
    delete_package_content_after_download_duration?: number;
    /**
     * Whether or not package contents have been deleted, either by the sender, by an administrator, or by configured expiration policies.
     * @type {boolean}
     * @memberof PackagesResponse
     */
    deleted?: boolean;
    /**
     * Whether or not package contents were deleted by a download-based expiration policy.
     * @type {boolean}
     * @memberof PackagesResponse
     */
    deleted_after_download?: boolean;
    /**
     * The timestamp for the deletion of package contents.
     * @type {string}
     * @memberof PackagesResponse
     */
    deleted_at?: string;
    /**
     * Whether or not the deleted package was deleted by an administrator.
     * @type {boolean}
     * @memberof PackagesResponse
     */
    deleted_by_admin?: boolean;
    /**
     * The ID of the user who deleted the package.
     * @type {number}
     * @memberof PackagesResponse
     */
    deleted_by_user_id?: number;
    /**
     * 
     * @type {SendersRecipientsObject}
     * @memberof PackagesResponse
     */
    download_notification_recipients?: SendersRecipientsObject;
    /**
     * Whether or not the package is in draft status.
     * @type {boolean}
     * @memberof PackagesResponse
     */
    draft?: boolean;
    /**
     * The time the draft expired/expires.
     * @type {string}
     * @memberof PackagesResponse
     */
    draft_expires_at?: string;
    /**
     * Whether or not the package has encryption_at_rest applied.
     * @type {boolean}
     * @memberof PackagesResponse
     */
    encryption_at_rest?: boolean;
    /**
     * The reason for expiration. Package can be deleted by an administrator or by the sender, or can be deleted as a result of a configured time-based or download-based expiration policy.
     * @type {string}
     * @memberof PackagesResponse
     */
    expiration_reason?: string;
    /**
     * Whether or not the package contents are expired due to a configured expiration policy.
     * @type {boolean}
     * @memberof PackagesResponse
     */
    expired?: boolean;
    /**
     * The time the package expired/expires.
     * @type {string}
     * @memberof PackagesResponse
     */
    expired_at?: string;
    /**
     * Whether or not the transfer of this package failed.
     * @type {boolean}
     * @memberof PackagesResponse
     */
    failed?: boolean;
    /**
     * The number of failed downloads of this package; download attempts may be full (the entire package) or partial (some contents of the package).
     * @type {number}
     * @memberof PackagesResponse
     */
    failed_download_count?: number;
    /**
     * The number of files included in this package. This counts individual files included in the package, not files that are contents of folders that are included in the package.
     * @type {number}
     * @memberof PackagesResponse
     */
    file_count?: number;
    /**
     * Whether or not the file_count value was obtained from the storage.
     * @type {boolean}
     * @memberof PackagesResponse
     */
    file_count_from_disk?: boolean;
    /**
     * The ID for the file comprising all package contents.
     * @type {string}
     * @memberof PackagesResponse
     */
    file_id?: string;
    /**
     * The number of files that have completed transferring.
     * @type {number}
     * @memberof PackagesResponse
     */
    files_completed?: number;
    /**
     * Number (obtained directly from the node) of files expected to be transferred as part of the package.
     * @type {number}
     * @memberof PackagesResponse
     */
    files_expected?: number;
    /**
     * The number of folders actually included in this package per the transfer session. This counts individual folder included in the package, not folders that are nested within other folders that are included in the package. This value may or may not match the value for folders_expected.
     * @type {number}
     * @memberof PackagesResponse
     */
    folder_count?: number;
    /**
     * Number (obtained directly from the node) of folders successfully transferred as part of the package.
     * @type {number}
     * @memberof PackagesResponse
     */
    folders_completed?: number;
    /**
     * Number (obtained directly from the node) of folders expected to be transferred as part of the package.
     * @type {number}
     * @memberof PackagesResponse
     */
    folders_expected?: number;
    /**
     * The number of full downloads completed for this package. This counts the times that recipients have downloaded the package as a whole, rather than partial downloads, when a recipient downloads individual files or folders of a package.
     * @type {number}
     * @memberof PackagesResponse
     */
    full_download_count?: number;
    /**
     * Whether or not the package has contents. If content has been deleted, either by the user, by an administrator, or as the result of configured package expiration policies, the package record remains accessible, but the package content has been deleted from the transfer server and cannot be recovered.
     * @type {boolean}
     * @memberof PackagesResponse
     */
    has_content?: boolean;
    /**
     * The ID for the package.
     * @type {string}
     * @memberof PackagesResponse
     */
    id?: string;
    /**
     * A metadata schema is used to present a form to a user when the user is submitting content to a dropbox. It is an array with \"Field\" objects, and each Field object defines one field that the user can fill out when submitting content to a dropbox. Note that the order of the fields in the metadata schema array will be the order in which they are shown to the user.
     * @type {Array<Metadatum>}
     * @memberof PackagesResponse
     */
    metadata?: Array<Metadatum>;
    /**
     * Package name.
     * @type {string}
     * @memberof PackagesResponse
     */
    name?: string;
    /**
     * The ID of the node that contains the package.
     * @type {number}
     * @memberof PackagesResponse
     */
    node_id?: number;
    /**
     * The sender\'s message to recipients to include with the package. Maximum characters: 65535.
     * @type {string}
     * @memberof PackagesResponse
     */
    note?: string;
    /**
     * 
     * @type {object}
     * @memberof PackagesResponse
     */
    package_sent?: object;
    /**
     * Whether or not the package was read. If user_package only.
     * @type {boolean}
     * @memberof PackagesResponse
     */
    read?: boolean;
    /**
     * When the package was recalled.
     * @type {string}
     * @memberof PackagesResponse
     */
    recalled_at?: string;
    /**
     * Whether or not the package was received. If user_package only.
     * @type {boolean}
     * @memberof PackagesResponse
     */
    received?: boolean;
    /**
     * 
     * @type {SendersRecipientsObject}
     * @memberof PackagesResponse
     */
    recipients?: SendersRecipientsObject;
    /**
     * 
     * @type {SendersRecipientsObject}
     * @memberof PackagesResponse
     */
    sender?: SendersRecipientsObject;
    /**
     * Whether or not the package was sent.
     * @type {boolean}
     * @memberof PackagesResponse
     */
    sent?: boolean;
    /**
     * The timestamp for when the package was sent.
     * @type {string}
     * @memberof PackagesResponse
     */
    sent_at?: string;
    /**
     * Whether or not all the contents of this package originate from the same location (node, workstation, etc.). When the package recipient downloads a package with Encryption at Rest (EAR) applied by the sender or by workspace configuration, and all package contents are from the same source (for example, the sender\'s desktop; a specific remote server), AoC signals Aspera Connect to prompt the recipient to apply the passphrase created by the sender and decrypt package contents during the download operation. When package contents are from disparate sources, previous behavior applies: the recipient applies the password to individual files in the downloaded package when opening each file.
     * @type {boolean}
     * @memberof PackagesResponse
     */
    single_source?: boolean;
    /**
     * The cumulative size of all the files and folders in the package.
     * @type {number}
     * @memberof PackagesResponse
     */
    size?: number;
    /**
     * The time remaining to complete an in-progress transfer. Float.
     * @type {number}
     * @memberof PackagesResponse
     */
    time_remaining?: number;
    /**
     * The number of transfer sessions expected to bring all package contents to the node supporting the workspace in which the package is sent. The number corresponds to the number of discrete source locations of the designated package contents. For example, if the package includes 20 files and folders from 5 discrete sources, the number of transfers expected is 5.
     * @type {number}
     * @memberof PackagesResponse
     */
    transfers_expected?: number;
    /**
     * When the package was updated.
     * @type {string}
     * @memberof PackagesResponse
     */
    updated_at?: string;
    /**
     * 
     * @type {SendersRecipientsObject}
     * @memberof PackagesResponse
     */
    upload_notification_recipients?: SendersRecipientsObject;
    /**
     * Whether or not the upload of the package has started.
     * @type {boolean}
     * @memberof PackagesResponse
     */
    upload_started?: boolean;
    /**
     * The timestamp for when the package upload began.
     * @type {string}
     * @memberof PackagesResponse
     */
    upload_started_at?: string;
    /**
     * If true, the package is watermarked
     * @type {boolean}
     * @memberof PackagesResponse
     */
    watermark?: boolean;
    /**
     * Status of the watermarking job. Allowable values:\"COMPLETE\", \"IN_PROGRESS\", \"PENDING\", \"ERROR\".
     * @type {string}
     * @memberof PackagesResponse
     */
    watermark_status?: string;
    /**
     * Percentage progress of the watermarking job
     * @type {number}
     * @memberof PackagesResponse
     */
    watermark_progress?: number;
    /**
     * Watermarking configuration details
     * @type {object}
     * @memberof PackagesResponse
     */
    watermark_details?: object;
    /**
     * ID of the workspace from which this package was sent
     * @type {number}
     * @memberof PackagesResponse
     */
    workspace_id?: number;
}
/**
 * 
 * @export
 * @interface SendersRecipientsObject
 */
export interface SendersRecipientsObject {
    /**
     * ID of the recipient
     * @type {string}
     * @memberof SendersRecipientsObject
     */
    id: string;
    /**
     * First and last names of the sender/recipient
     * @type {string}
     * @memberof SendersRecipientsObject
     */
    name?: string;
    /**
     * 
     * @type {Type2}
     * @memberof SendersRecipientsObject
     */
    type?: Type2;
}
/**
 * 
 * @export
 * @interface Setting
 */
export interface Setting {
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Setting
     */
    value?: boolean;
}
/**
 * If a transfer node has status \"error\" but the problem has been fixed, it will automatically recover to the \"ok\" state. Similarly, if a node has status \"ok\", it will switch to status \"error\" automatically if there is a problem. Nodes with status \"down\" remain in the \"down\" state until marked \"ok\" by a user.
 * @export
 * @enum {string}
 */
export enum Status {
    Ok = 'ok',
    Error = 'error',
    Down = 'down'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Target {
    Field = 'field',
    Parameter = 'parameter',
    Header = 'header'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Type {
    User = 'user',
    Group = 'group',
    Email = 'email'
}

/**
 * Entity type of the recipient
 * @export
 * @enum {string}
 */
export enum Type2 {
    User = 'user',
    Group = 'group'
}

/**
 * 
 * @export
 * @interface UsageReportsResponse
 */
export interface UsageReportsResponse {
    /**
     * The ID of the transfer node for which this usage report was generated.
     * @type {string}
     * @memberof UsageReportsResponse
     */
    node_id?: string;
    /**
     * The total number of bytes transferred during this reporting period.
     * @type {number}
     * @memberof UsageReportsResponse
     */
    reporting_period_bytes?: number;
    /**
     * The total number of bytes received during this reporting period.
     * @type {number}
     * @memberof UsageReportsResponse
     */
    reporting_period_bytes_in?: number;
    /**
     * The total number of bytes sent during this reporting period.
     * @type {number}
     * @memberof UsageReportsResponse
     */
    reporting_period_bytes_out?: number;
    /**
     * The total number of bytes transferred since the transfer node started collecting usage information.
     * @type {number}
     * @memberof UsageReportsResponse
     */
    total_bytes?: number;
    /**
     * The total number bytes received since the transfer node started collecting usage information.
     * @type {number}
     * @memberof UsageReportsResponse
     */
    total_bytes_in?: number;
    /**
     * The total number of bytes sent since the transfer node started collecting usage information.
     * @type {number}
     * @memberof UsageReportsResponse
     */
    total_bytes_out?: number;
    /**
     * The date at which this usage report was last updated.
     * @type {string}
     * @memberof UsageReportsResponse
     */
    updated_at?: string;
    /**
     * The ID of the workspace for which this usage report was generated.
     * @type {string}
     * @memberof UsageReportsResponse
     */
    workspace_id?: string;
}
/**
 * Information about the Aspera on Cloud (AoC) user
 * @export
 * @interface User
 */
export interface User {
    /**
     * AoC user ID
     * @type {string}
     * @memberof User
     */
    id: string;
    /**
     * AoC user email
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * AoC username
     * @type {string}
     * @memberof User
     */
    name: string;
    /**
     * Timestamp for AoC user\'s first login
     * @type {string}
     * @memberof User
     */
    first_login_at: string;
    /**
     * Timestamp for AoC user\'s last login
     * @type {string}
     * @memberof User
     */
    last_login_at: string;
    /**
     * Unique hash for the AoC user
     * @type {string}
     * @memberof User
     */
    unique_hash?: string;
}
/**
 * 
 * @export
 * @interface UsersParams
 */
export interface UsersParams {
    /**
     * PUT User, Manager, Admin for self.
     * @type {string}
     * @memberof UsersParams
     */
    avatar_image_data?: string;
    /**
     * The image type of the avatar image data. PUT User, Manager, Admin for self.
     * @type {string}
     * @memberof UsersParams
     */
    avatar_image_type?: string;
    /**
     * Whether or not this user is deactivated. A deactivated user cannot log in to Aspera on Cloud, but still exists in the user database. PUT Admin permission required.
     * @type {boolean}
     * @memberof UsersParams
     */
    deactivated?: boolean;
    /**
     * The workspace selected by the user as their default; when the user logs in to Aspera on Cloud, the default workspace displays. If the user has not selected a default workspace, the last used workspace displays. PUT User, Manager, Admin for self. POST Manager permission required. POST Admin permission required.
     * @type {string}
     * @memberof UsersParams
     */
    default_workspace_choice?: string;
    /**
     * The ID of the user-selected default workspace. If the user has not selected a default workspace, the field contains the ID of the user\'s last used workspace. PUT User, Manager, Admin for self. POST Manager permission required. POST Admin permission required.
     * @type {string}
     * @memberof UsersParams
     */
    default_workspace_id?: string;
    /**
     * The email address associated with this user in the AoC user database. This is the user\'s login username. PUT User, Manager, Admin for self. POST Manager permission required. POST Admin permission required. Required only for POST.
     * @type {string}
     * @memberof UsersParams
     */
    email: string;
    /**
     * The user\'s first name. PUT User, Manager, Admin for self. POST Manager permission required. POST Admin permission required.
     * @type {string}
     * @memberof UsersParams
     */
    first_name?: string;
    /**
     * The ID for the user. PUT User, Manager, Admin for self.
     * @type {number}
     * @memberof UsersParams
     */
    ibm_uid?: number;
    /**
     * The user\'s last name. PUT User, Manager, Admin for self. POST Manager permission required. POST Admin permission required.
     * @type {string}
     * @memberof UsersParams
     */
    last_name?: string;
    /**
     * The user first_name and last_name. PUT User, Manager, Admin for self. POST Manager permission required. POST Admin permission required.
     * @type {string}
     * @memberof UsersParams
     */
    name?: string;
    /**
     * Whether or not this user has administrative privileges in the organization. PUT Admin permission required.
     * @type {boolean}
     * @memberof UsersParams
     */
    organization_admin?: boolean;
    /**
     * Whether or not the user record for this user includes the user\'s public key. The user can add their public key to their record, or the organization administrator can add it. PUT User, Manager, Admin for self. POST Manager permission required. POST Admin permission required.
     * @type {boolean}
     * @memberof UsersParams
     */
    public_key?: boolean;
    /**
     * future feature PUT Admin permission required.
     * @type {boolean}
     * @memberof UsersParams
     */
    subscription_admin?: boolean;
    /**
     * future feature PUT Admin permission required.
     * @type {boolean}
     * @memberof UsersParams
     */
    user_admin?: boolean;
}
/**
 * 
 * @export
 * @interface UsersResponse
 */
export interface UsersResponse {
    /**
     * Whether or not this user has ATS (Aspera Transfer Service) administrative permissions.
     * @type {boolean}
     * @memberof UsersResponse
     */
    ats_admin?: boolean;
    /**
     * future feature
     * @type {string}
     * @memberof UsersResponse
     */
    available_apps?: string;
    /**
     * The timestamp for initial creation of this user. datetime
     * @type {string}
     * @memberof UsersResponse
     */
    created_at?: string;
    /**
     * Whether or not this user is deactivated. A deactivated user cannot log in to Aspera on Cloud, but still exists in the user database.
     * @type {boolean}
     * @memberof UsersResponse
     */
    deactivated?: boolean;
    /**
     * When shortened links are enabled for a workspace, and this user has permission to send an invitation inviting another person to send them a package, this is the default configuration of the shortened link for this user. The default shortened link is comprised of \'first_name\' and \'last_name\' for this user.
     * @type {string}
     * @memberof UsersResponse
     */
    default_shortlink_name?: string;
    /**
     * The workspace selected by the user as their default; when the user logs in to Aspera on Cloud, the default workspace displays. If the user has not selected a default workspace, the last used workspace displays.
     * @type {string}
     * @memberof UsersResponse
     */
    default_workspace_choice?: string;
    /**
     * The ID of the user-selected default workspace. If the user has not selected a default workspace, the field contains the ID of the user\'s last used workspace.
     * @type {string}
     * @memberof UsersResponse
     */
    default_workspace_id?: string;
    /**
     * The email address associated with this user in the Aspera on Cloud user database. This is the user\'s login username.
     * @type {string}
     * @memberof UsersResponse
     */
    email?: string;
    /**
     * The user\'s first name.
     * @type {string}
     * @memberof UsersResponse
     */
    first_name?: string;
    /**
     * The file ID of the user\'s root or home folder, which contains all files and folders the user uploads, along with links to folders shared with this user by the administrator or by other users.
     * @type {number}
     * @memberof UsersResponse
     */
    home_file_id?: number;
    /**
     * The ID of the node containing the user\'s home folder.
     * @type {number}
     * @memberof UsersResponse
     */
    home_node_id?: number;
    /**
     * The ID for the user.
     * @type {number}
     * @memberof UsersResponse
     */
    id?: number;
    /**
     * The timestamp for the last time the user logged in. datetime
     * @type {string}
     * @memberof UsersResponse
     */
    last_login_at?: string;
    /**
     * The authorization method used for the most recent login.
     * @type {string}
     * @memberof UsersResponse
     */
    last_login_provider?: string;
    /**
     * The user\'s last name.
     * @type {string}
     * @memberof UsersResponse
     */
    last_name?: string;
    /**
     * Whether or not the user has membership in any workspace. Refer to .
     * @type {boolean}
     * @memberof UsersResponse
     */
    member_of_any_workspace?: boolean;
    /**
     * The user first_name and last_name.
     * @type {string}
     * @memberof UsersResponse
     */
    name?: string;
    /**
     * Whether or not this user has administrative privileges in the organization.
     * @type {boolean}
     * @memberof UsersResponse
     */
    organization_admin?: boolean;
    /**
     * ID of the AoC organization to which the client belongs.
     * @type {number}
     * @memberof UsersResponse
     */
    organization_id?: number;
    /**
     * The timestamp for the most recent update to the user password. datetime
     * @type {string}
     * @memberof UsersResponse
     */
    password_updated_at?: string;
    /**
     * Whether or not the user record for this user includes the user\'s public key. The user can add their public key to their record, or the organization administrator can add it.
     * @type {boolean}
     * @memberof UsersResponse
     */
    public_key?: boolean;
    /**
     * The file ID of the home folder for a user who may have access to some shared folders in the workspace, but is not a member of the workspace.
     * @type {string}
     * @memberof UsersResponse
     */
    read_only_home_file_id?: string;
    /**
     * The ID of the node containing the user\'s read-only home folder.
     * @type {number}
     * @memberof UsersResponse
     */
    read_only_home_node_id?: number;
    /**
     * The number of user-related operations currently in progress.
     * @type {number}
     * @memberof UsersResponse
     */
    running_operation_count?: number;
    /**
     * The ID for this user in the SAML authentication login. If user is not a SAML user, set this parameter to null.
     * @type {string}
     * @memberof UsersResponse
     */
    saml_configuration_id?: string;
    /**
     * The number of user-related operations that are stopped for any reason.
     * @type {number}
     * @memberof UsersResponse
     */
    stopped_operation_count?: number;
    /**
     * future feature
     * @type {boolean}
     * @memberof UsersResponse
     */
    subscription_admin?: boolean;
    /**
     * Whether or not this org/user is a trial
     * @type {boolean}
     * @memberof UsersResponse
     */
    trial?: boolean;
    /**
     * The timestamp for when the user record was most recently updated. datetime
     * @type {string}
     * @memberof UsersResponse
     */
    updated_at?: string;
    /**
     * future feature
     * @type {boolean}
     * @memberof UsersResponse
     */
    user_admin?: boolean;
}
/**
 * 
 * @export
 * @interface WatermarkProfileCreateParams
 */
export interface WatermarkProfileCreateParams {
    /**
     * Name of the watermarking profile
     * @type {string}
     * @memberof WatermarkProfileCreateParams
     */
    name: string;
    /**
     * Tenant ID associated with the watermarking profile
     * @type {string}
     * @memberof WatermarkProfileCreateParams
     */
    tenant_id: string;
    /**
     * Irdeto digital watermarking endpoint
     * @type {string}
     * @memberof WatermarkProfileCreateParams
     */
    dwm_api_url: string;
    /**
     * Cloud provider region in which the watermarking profile is being used
     * @type {string}
     * @memberof WatermarkProfileCreateParams
     */
    cloud_region: string;
    /**
     * Cloud provider for which which the watermarking profile is being used, for example, AWS
     * @type {string}
     * @memberof WatermarkProfileCreateParams
     */
    cloud_provider: string;
}
/**
 * 
 * @export
 * @interface WatermarkProfileResponse
 */
export interface WatermarkProfileResponse {
    /**
     * Cloud provider for which which the watermarking profile is being used, for example, AWS
     * @type {string}
     * @memberof WatermarkProfileResponse
     */
    cloud_provider: string;
    /**
     * Cloud provider region in which the xing profile is being used
     * @type {string}
     * @memberof WatermarkProfileResponse
     */
    cloud_region: string;
    /**
     * Timestamp for when the watermarking profile was created
     * @type {string}
     * @memberof WatermarkProfileResponse
     */
    created_at: string;
    /**
     * Watermarking profile description
     * @type {string}
     * @memberof WatermarkProfileResponse
     */
    description: string;
    /**
     * Irdeto digital watermarking endpoint
     * @type {string}
     * @memberof WatermarkProfileResponse
     */
    dwm_api_url: string;
    /**
     * ID of the watermarking profile
     * @type {string}
     * @memberof WatermarkProfileResponse
     */
    id: string;
    /**
     * Name of the watermarking profile
     * @type {string}
     * @memberof WatermarkProfileResponse
     */
    name: string;
    /**
     * Tenant ID associated with the watermarking profile
     * @type {string}
     * @memberof WatermarkProfileResponse
     */
    tenant_id: string;
    /**
     * Timestamp for when the watermarking profile was last updated
     * @type {string}
     * @memberof WatermarkProfileResponse
     */
    updated_at: string;
    /**
     * Nodes which are available for use with this watermarking profile. These nodes are returned only if the query parameter include=available_nodes is included.
     * @type {Array<NodesResponse>}
     * @memberof WatermarkProfileResponse
     */
    available_nodes?: Array<NodesResponse>;
}
/**
 * 
 * @export
 * @interface WatermarkProfileUpdateParams
 */
export interface WatermarkProfileUpdateParams {
    /**
     * Name of the watermarking profile
     * @type {string}
     * @memberof WatermarkProfileUpdateParams
     */
    name?: string;
    /**
     * Watermarking profile description
     * @type {string}
     * @memberof WatermarkProfileUpdateParams
     */
    description?: string;
    /**
     * Irdeto digital watermarking endpoint
     * @type {string}
     * @memberof WatermarkProfileUpdateParams
     */
    dwm_api_url?: string;
    /**
     * Cloud provider for which which the watermarking profile is being used, for example, AWS
     * @type {string}
     * @memberof WatermarkProfileUpdateParams
     */
    cloud_provider?: string;
    /**
     * Cloud provider region in which the watermarking profile is being used
     * @type {string}
     * @memberof WatermarkProfileUpdateParams
     */
    cloud_region?: string;
}
/**
 * 
 * @export
 * @interface WorkspaceFilterParams
 */
export interface WorkspaceFilterParams {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceFilterParams
     */
    created_at?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceFilterParams
     */
    manager?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceFilterParams
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkspaceFilterParams
     */
    node_id?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceFilterParams
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface WorkspaceMembershipsParams
 */
export interface WorkspaceMembershipsParams {
    /**
     * Whether or not inviting users to this workspace by email is allowed.
     * @type {boolean}
     * @memberof WorkspaceMembershipsParams
     */
    can_invite_by_email?: boolean;
    /**
     * The user is a workspace manager user type.
     * @type {boolean}
     * @memberof WorkspaceMembershipsParams
     */
    manager?: boolean;
    /**
     * The ID of the member
     * @type {number}
     * @memberof WorkspaceMembershipsParams
     */
    member_id: number;
    /**
     * The member type.
     * @type {string}
     * @memberof WorkspaceMembershipsParams
     */
    member_type: string;
    /**
     * Whether or not storage is allowed.
     * @type {boolean}
     * @memberof WorkspaceMembershipsParams
     */
    storage_allowed?: boolean;
    /**
     * The ID of the workspace in which to grant this membership.
     * @type {number}
     * @memberof WorkspaceMembershipsParams
     */
    workspace_id: number;
}
/**
 * 
 * @export
 * @interface WorkspaceMembershipsResponse
 */
export interface WorkspaceMembershipsResponse {
    /**
     * Membership ID.
     * @type {string}
     * @memberof WorkspaceMembershipsResponse
     */
    id?: string;
    /**
     * The membership in this workspace is \'inherited\'. The user is not a direct member, but rather a member by means of being a member of a group that is a member of the workspace.
     * @type {boolean}
     * @memberof WorkspaceMembershipsResponse
     */
    inherited?: boolean;
    /**
     * The user is a workspace manager user type.
     * @type {boolean}
     * @memberof WorkspaceMembershipsResponse
     */
    manager?: boolean;
    /**
     * The ID of the member.
     * @type {number}
     * @memberof WorkspaceMembershipsResponse
     */
    member_id?: number;
    /**
     * The user type for this member. Valid values- user, group.
     * @type {string}
     * @memberof WorkspaceMembershipsResponse
     */
    member_type?: string;
    /**
     * The number of workspace-membership-related operations currently in progress.
     * @type {number}
     * @memberof WorkspaceMembershipsResponse
     */
    running_operation_count?: number;
    /**
     * The number of workspace-membership-related operations that are stopped for any reason.
     * @type {number}
     * @memberof WorkspaceMembershipsResponse
     */
    stopped_operation_count?: number;
    /**
     * Whether or not storage is allowed.
     * @type {boolean}
     * @memberof WorkspaceMembershipsResponse
     */
    storage_allowed?: boolean;
    /**
     * The ID of the workspace.
     * @type {number}
     * @memberof WorkspaceMembershipsResponse
     */
    workspace_id?: number;
}
/**
 * 
 * @export
 * @interface WorkspaceMembershipsUpdateParams
 */
export interface WorkspaceMembershipsUpdateParams {
    /**
     * Whether or not inviting users to this workspace by email is allowed.
     * @type {boolean}
     * @memberof WorkspaceMembershipsUpdateParams
     */
    can_invite_by_email?: boolean;
    /**
     * The user is a workspace manager user type.
     * @type {boolean}
     * @memberof WorkspaceMembershipsUpdateParams
     */
    manager?: boolean;
    /**
     * Whether or not storage is allowed.
     * @type {boolean}
     * @memberof WorkspaceMembershipsUpdateParams
     */
    storage_allowed?: boolean;
}
/**
 * 
 * @export
 * @interface WorkspaceQueryParams
 */
export interface WorkspaceQueryParams {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceQueryParams
     */
    created_at?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceQueryParams
     */
    manager?: boolean;
    /**
     * full text search
     * @type {string}
     * @memberof WorkspaceQueryParams
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkspaceQueryParams
     */
    node_id?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceQueryParams
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface WorkspacesParams
 */
export interface WorkspacesParams {
    /**
     * Allow senders to set package expiration when sending. If workspace settings are configured by the admin, senders can only further restrict the workspace setting. Refer to delete_package_content_after_download_duration and to content_retention_duration. POST: Admin permission required. PUT: Admin or Manager permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    allow_package_level_expirations?: boolean;
    /**
     * Allow workspace manager to configure workspace collaboration settings. POST: Admin permission required. PUT: Admin permission required. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    collaboration_settings_editable_by_managers?: boolean;
    /**
     * If collaboration with users outside the workspace is enabled (external_package_sending_allowed=true and/or external_sharing_allowed=true), enable a whitelist of external users who can be recipients of packages and/or shared folders. To configure the whitelist, POST or PUT to /workspace_collaborators. POST: Admin permission required. PUT: Manager with collaboration settings edit permission or Admin permission required. settings editable by managers required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    collaboration_whitelist_enabled?: boolean;
    /**
     * If external_package_sending_allowed(_by_managers) and/or external_sharing_allowed(_by_managers) is/are set to true, setting this parameter to true allows those who are allowed to send to or share with external users (all users or workspace managers only) to see email addresses of external users in the list of contacts displayed in the (1) recipients field of the package sending form, and/or (2) the recipients field of the folder sharing form. POST Admin permission required. PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    collaboration_with_emails_allowed?: boolean;
    /**
     * Configure a time-based expiration policy for packages in this workspace by setting this parameter to a non-null value. Once the transfer completes, a timer begins. After the duration configured for this parameter, package contents are deleted (the package record is maintained, and includes details about sender, recipients, contents, transfer). If null, contents of packages in this workspace are not deleted based on time. To set a download-based expiration policy, refer to delete_package_content_after_download_duration. Valid values: null - 10 years. Units: seconds. POST: Admin permission required. PUT Manager or Admin permission required. RESPONSE User scope. RESPONSE Admin scope (org admin).
     * @type {number}
     * @memberof WorkspacesParams
     */
    content_retention_duration?: number;
    /**
     * When this parameter is set to true, encryption-at-rest is mandatory for all packages sent in this workspace. Senders must set a passphrase for every package they send, then must deliver the passphrase to the recipient according to local site security practice. Only when the recipient applies that passphrase can the package be decrypted. When this parameter is set to true, the parameter of the /packages endpoint that corresponds to EAR is always set to true and cannot be edited. When this parameter is set to false, the field in the /packages endpoint can be set to true or false, giving the sender the choice whether to apply EAR to a given package or not. POST: Admin permission required. PUT: Admin or  Manager permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    default_ear_setting?: boolean;
    /**
     * Configure a download-based expiration policy for packages in this workspace by setting this parameter to a non-null value. Once all package recipients have downloaded the entire package, a timer begins. After the duration configured for this parameter, package contents are deleted (the package record is maintained, and includes details about sender, recipients, contents, transfer). If null, contents of packages in this workspace are not deleted based on whether or not recipients have downloaded the package. To set a time-based expiration policy, refer to content_retention_duration. Valid values: null - 10 years. Units: seconds. POST: Admin permission required. PUT: Manager or Admin permission required.  RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {number}
     * @memberof WorkspacesParams
     */
    delete_package_content_after_download_duration?: number;
    /**
     * A description for the workspace. POST: Admin permission required. PUT: Manager or Admin permission required. RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesParams
     */
    description?: string;
    /**
     * Configure a time-based expiration policy for draft packages in this workspace by setting this parameter to a non-null value. When a package is saved as a draft, a timer begins. After the duration configured for this parameter, draft package contents are deleted. If null, contents of draft packages in this workspace are not deleted based on time. To set a time-based expiration policy for non-draft packages in this workspace, refer to content_retention_duration. POST: Admin permission required. PUT Manager or Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {number}
     * @memberof WorkspacesParams
     */
    draft_expiration_duration?: number;
    /**
     * If \'inherit_email_templates\' is set to false, configure the footer for email notifications for this workspace. The footer you configure is common to all email notifications for this workspace. POST: Admin permission required. PUT: Manager or Admin permission required. RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesParams
     */
    email_footer?: string;
    /**
     * 
     * @type {EmailNotificationSettings}
     * @memberof WorkspacesParams
     */
    email_notification_settings?: EmailNotificationSettings;
    /**
     * If \'inherit_email_templates\' is set to false, you can enable or disable the ability to configure email templates specifically for users outside this workspace. When this parameter is set to false, external recipients receive the same email notification messages that users in the workspace receive. POST: Admin permission required. PUT: Admin permission required. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    enable_external_email_templates?: boolean;
    /**
     * Not used.
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    enable_external_notifications?: boolean;
    /**
     * If event_reporting_uri is configured, users can submit JSON of all acceptable headers. If event_reporting_uri is not configured, this parameter does not apply. POST: Admin permission required. Maximum characters: 65535.
     * @type {string}
     * @memberof WorkspacesParams
     */
    event_reporting_headers?: string;
    /**
     * The URI to collect event and activity reports. If this parameter is not null, you can use the event_reporting_headers parameter to configure acceptable JSON headers. POST Admin permission required. PUT Manager permission required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesParams
     */
    event_reporting_uri?: string;
    /**
     * Require external recipients of packages sent from this workspace to authenticate before they can access the package. POST: Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    external_package_authentication_required?: boolean;
    /**
     * Allow members of this workspace to send packages to (1) people outside the workspace and (2) to people who do not have an AoC account. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    external_package_sending_allowed?: boolean;
    /**
     * Allow workspace managers of this workspace to send packages to (1) people outside the workspace and (2) to people who do not have a Files account. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    external_package_sending_allowed_by_managers?: boolean;
    /**
     * Allow members of this workspace to share folders with (1) people outside the workspace and (2) with people who do not have an AoC account. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required.
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    external_sharing_allowed?: boolean;
    /**
     * Allow workspace managers of this workspace to share folders with (1) people outside the workspace and (2) with people who do not have an AoC account. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    external_sharing_allowed_by_managers?: boolean;
    /**
     * The file ID of the folder containing users\' home folders for this workspace. POST Admin permission required. PUT Manager permission required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesParams
     */
    home_container_file_id?: string;
    /**
     * The image data encoded as a string. POST Admin permission required. PUT Manager permission required or PUT Admin permission required. RESPONSE User scope if params[:include]=true. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesParams
     */
    image_data?: string;
    /**
     * The image type of the workspace logo; for example, image/png or image/jpg. POST Admin permission required. PUT Manager permission required or PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesParams
     */
    image_type?: string;
    /**
     * Inherit the email notification settings configured at the organization. If set to false, you can configure external email notification settings for this workspace; see \'enable_external_notifications\'. POST Admin permission required. PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    inherit_email_notification_settings?: boolean;
    /**
     * Whether or not to inherit the email templates configured at the organization. If set to true, the workspace inherits the settings configured at the organization level. If set to false, you can configure email template settings for this workspace; see \'enable_external_email_templates\' and other email notification settings. POST Admin permission required. PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    inherit_email_templates?: boolean;
    /**
     * Whether or not the workspace inherits external notifications. PUT Admin permission required.
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    inherit_external_notifications?: boolean;
    /**
     * Allow members of this workspace to invite users outside the workspace to become workspace members. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    invitations_allowed?: boolean;
    /**
     * Allow workspace managers of this workspace to invite users outside the workspace to become workspace members. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    invitations_allowed_by_managers?: boolean;
    /**
     * The workspace name. Query parameter for GET method. POST Admin permission required. PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesParams
     */
    name: string;
    /**
     * The ID of the node on which workspace folders and packages are stored. Query parameter for GET method. POST Admin permission required. PUT Manager permission required.
     * @type {number}
     * @memberof WorkspacesParams
     */
    node_id: number;
    /**
     * Whether or not package download counts are recorded. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    package_download_counts_enabled?: boolean;
    /**
     * Enable members of this workspace to configure personalized URLs to send when inviting people to submit packages (refer to public_links_allowed). You can set this parameter to true only if url_shortening_enabled is also set to true. Once you enable personalized URLs, you enable a default personalized URL construction and you also allow workspace member to configure the URLs they send. The default URL configuration contains the sender\'s username or the dropbox name; for example: https://aspera.pub/John_Doe;https://aspera.pub/Dropbox1. Note that dropboxes in the workspace inherit the settings you configure for the workspace as follows: When short URLs are enabled at the workspace (url_shortening_enabled=true): Short URLs are enabled for all dropboxes in that workspace. You cannot disable short URLs for a dropbox. When personalized URLs are enabled at the workspace: Personalized URLs are enabled for all dropboxes in that workspace. You can disable personalized URLs for specific dropboxes if desired. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required.
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    personalized_urls_enabled?: boolean;
    /**
     * Allow workspace members to send invitations to users outside the workspace, inviting them to send a package to (1) the user who issues the invitation, and (2) the dropboxes in which the user who issues the invitation is a member. An outside user can be a person who is a member of a different AoC workspace, or a person without an AoC account. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required.
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    public_invites_allowed?: boolean;
    /**
     * Allow workspace managers to send invitations to users outside the workspace, inviting them to send a package to (1) the workspace manager who issues the invitation, and (2) the dropboxes in which the workspace manager is a member. An outside user can be a person who is a member of a different AoC workspace, or a person without an AoC account. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    public_invites_allowed_by_managers?: boolean;
    /**
     * Allow users in the workspace to send a link to users outside the workspace, allowing them to access a file or folder that the inviter has access to in the workspace. An outside user can be a person who is a member of a different AoC workspace, or a person without an AoC account. The inviter must have proper permission to the file or folder being shared. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    public_links_allowed?: boolean;
    /**
     * Allow workspace managers to send a link to users outside the workspace, allowing them to access a file or folder that the inviter has access to in the workspace. An outside user can be a person who is a member of a different AoC workspace, or a person without an AoC account. The inviter must have proper permission to the file or folder being shared. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    public_links_allowed_by_managers?: boolean;
    /**
     * The file ID of the root folder containing packages for this workspace. POST Admin permission required. PUT Manager permission required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesParams
     */
    root_file_id?: string;
    /**
     * Where packages are stored POST Admin permission required. PUT Manager permission required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesParams
     */
    spool_file_id?: string;
    /**
     * Whether or not the users of this workspace can upload to their respective home folders. Set this parameter to false to prevent users from uploading to or creating new folders in their home folders. Restricting these functions is one way to control storage usage in the workspace. To exempt certain workspace members from this restriction, set storage_allowed to true for those members in /workspace_memberships. POST Admin permission required. PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    storage_allowed?: boolean;
    /**
     * When members of this workspace send a link that allows the recipeint to send a package (refer to public_invites_allowed), the link generated will have the shortened form; for example:  (compared to the standard URL; for example: ). When this parameter is set to true, you can also set personalized_urls_enabled to true. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    url_shortening_enabled?: boolean;
    /**
     * Enable watermarking on the workspace. Admin only.
     * @type {boolean}
     * @memberof WorkspacesParams
     */
    watermark?: boolean;
}
/**
 * 
 * @export
 * @interface WorkspacesResponse
 */
export interface WorkspacesResponse {
    /**
     * Allow senders to set package expiration when sending. If workspace settings are configured by the admin, senders can only further restrict the workspace setting. Refer to delete_package_content_after_download_duration and to content_retention_duration. POST Admin permission required. PUT Manager permission required or PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    allow_package_level_expirations?: boolean;
    /**
     * RESPONSE User scope if is_workspace_membership.
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    can_invite_by_email?: boolean;
    /**
     * Allow workspace manager to configure workspace collaboration settings. POST Admin permission required. PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    collaboration_settings_editable_by_managers?: boolean;
    /**
     * If collaboration with users outside the workspace is enabled (external_package_sending_allowed=true and/or external_sharing_allowed=true), enable a whitelist of external users who can be recipients of packages and/or shared folders. To configure the whitelist, POST or PUT to /workspace_collaborators. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    collaboration_whitelist_enabled?: boolean;
    /**
     * If external_package_sending_allowed(_by_managers) and/or external_sharing_allowed(_by_managers) is/are set to true, setting this parameter to true allows those who are allowed to send to or share with external users (all users or workspace managers only) to see email addresses of external users in the list of contacts displayed in the (1) recipients field of the package sending form, and/or (2) the recipients field of the folder sharing form. POST Admin permission required. PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    collaboration_with_emails_allowed?: boolean;
    /**
     * Configure a time-based expiration policy for packages in this workspace by setting this parameter to a non-null value. Once the transfer complete, a timer begins. After the duration configured for this parameter, package contents are deleted (the package record is maintained, and includes details about sender, recipients, contents, transfer). If null, contents of packages in this workspace are not deleted based on time. To set a download-based expiration policy, refer to delete_package_content_after_download_duration. Valid values (null - 10 years) Units (seconds) POST Admin permission required. PUT Manager permission required or PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (org admin).
     * @type {number}
     * @memberof WorkspacesResponse
     */
    content_retention_duration?: number;
    /**
     * datetime RESPONSE User scope. RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesResponse
     */
    created_at?: string;
    /**
     * When this parameter is set to true, encryption-at-rest is mandatory for all packages sent in this workspace. Senders must set a passphrase for every package they send, then must deliver the passphrase to the recipient according to local site security practice. Only when the recipient applies that passphrase can the package be decrypted. When this parameter is set to true, the parameter of the /packages endpoint that corresponds to EAR is always set to true and cannot be edited. When this parameter is set to false, the field in the /packages endpoint can be set to true or false, giving the sender the choice whether to apply EAR to a given package or not. POST Admin permission required. PUT Manager permission required or PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    default_ear_setting?: boolean;
    /**
     * Configure a download-based expiration policy for packages in this workspace by setting this parameter to a non-null value. Once all package recipients have downloaded the entire package, a timer begins. After the duration configured for this parameter, package contents are deleted (the package record is maintained, and includes details about sender, recipients, contents, transfer). If null, contents of packages in this workspace are not deleted based on whether or not recipients have downloaded the package. To set a time-based expiration policy, refer to content_retention_duration. Valid values (null - 10 years) Units (seconds) POST Admin permission required. PUT Manager permission required. or PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {number}
     * @memberof WorkspacesResponse
     */
    delete_package_content_after_download_duration?: number;
    /**
     * A description for the workspace. POST Admin permission required. PUT Manager permission required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesResponse
     */
    description?: string;
    /**
     * Configure a time-based expiration policy for draft packages in this workspace by setting this parameter to a non-null value. When a package is saved as a draft, a timer begins. After the duration configured for this parameter, draft package contents are deleted. If null, contents of draft packages in this workspace are not deleted based on time. To set a time-based expiration policy for non-draft packages in this workspace, refer to content_retention_duration. POST Admin permission required. PUT Manager permission required or PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {number}
     * @memberof WorkspacesResponse
     */
    draft_expiration_duration?: number;
    /**
     * RESPONSE User scope. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    effective_default_ear_setting?: boolean;
    /**
     * RESPONSE User scope if is_workspace_membership.
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    effective_storage_allowed?: boolean;
    /**
     * If \'inherit_email_templates\' is set to false, configure the footer for email notifications for this workspace. The footer you configure is common to all email notifications for this workspace. POST Admin permission required. PUT Manager permission required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesResponse
     */
    email_footer?: string;
    /**
     * 
     * @type {EmailNotificationSettings}
     * @memberof WorkspacesResponse
     */
    email_notification_settings?: EmailNotificationSettings;
    /**
     * If \'inherit_email_templates\' is set to false, you can enable or disable the ability to configure email templates specifically for users outside this workspace. When this parameter is set to false, external recipients receive the same email notification messages that users in the workspace receive. POST Admin permission required. PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    enable_external_email_templates?: boolean;
    /**
     * Not used. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    enable_external_notifications?: boolean;
    /**
     * If event_reporting_uri is configured, users can submit JSON of all acceptable headers. If event_reporting_uri is not configured, this parameter does not apply. POST Admin permission required.
     * @type {string}
     * @memberof WorkspacesResponse
     */
    event_reporting_headers?: string;
    /**
     * The URI to collect event and activity reports. If this parameter is not null, you can use the event_reporting_headers parameter to configure acceptable JSON headers. POST Admin permission required. PUT Manager permission required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesResponse
     */
    event_reporting_uri?: string;
    /**
     * Require external recipients of packages sent from this workspace to authenticate before they can access the package. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    external_package_authentication_required?: boolean;
    /**
     * Allow members of this workspace to send packages to (1) people outside the workspace and (2) to people who do not have an AoC account. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    external_package_sending_allowed?: boolean;
    /**
     * Allow workspace managers of this workspace to send packages to (1) people outside the workspace and (2) to people who do not have an AoC account. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    external_package_sending_allowed_by_managers?: boolean;
    /**
     * Allow members of this workspace to share folders with (1) people outside the workspace and (2) with people who do not have an AoC account. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required.
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    external_sharing_allowed?: boolean;
    /**
     * Allow workspace managers of this workspace to share folders with (1) people outside the workspace and (2) with people who do not have an AoC account. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    external_sharing_allowed_by_managers?: boolean;
    /**
     * The ID of the group containing all members of this workspace. RESPONSE User scope. RESPONSE Admin scope (org admin).
     * @type {number}
     * @memberof WorkspacesResponse
     */
    group_id?: number;
    /**
     * The file ID of the folder containing users\' home folders for this workspace. POST Admin permission required. PUT Manager permission required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesResponse
     */
    home_container_file_id?: string;
    /**
     * RESPONSE User scope if is_workspace_membership.
     * @type {number}
     * @memberof WorkspacesResponse
     */
    home_file_id?: number;
    /**
     * RESPONSE User scope if is_workspace_membership.
     * @type {number}
     * @memberof WorkspacesResponse
     */
    home_node_id?: number;
    /**
     * The ID of the workspace. RESPONSE User scope. RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesResponse
     */
    id?: string;
    /**
     * The image data encoded as a string. POST Admin permission required. PUT Manager permission required or PUT Admin permission required. RESPONSE User scope if params[:include]=true. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesResponse
     */
    image_data?: string;
    /**
     * The image type of the workspace logo; for example, image/png or image/jpg. POST Admin permission required. PUT Manager permission required or PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesResponse
     */
    image_type?: string;
    /**
     * The URL of the image. RESPONSE User scope. RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesResponse
     */
    image_url?: string;
    /**
     * Inherit the email notification settings configured at the organization. If set to false, you can configure external email notification settings for this workspace; see \'enable_external_notifications\'. POST Admin permission required. PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    inherit_email_notification_settings?: boolean;
    /**
     * Whether or not to inherit the email templates configured at the organization. If set to true, the workspace inherits the settings configured at the organization level. If set to false, you can configure email template settings for this workspace; see \'enable_external_email_templates\' and other email notification settings. POST Admin permission required. PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    inherit_email_templates?: boolean;
    /**
     * Whether or not the workspace inherits external notifications. PUT Admin permission required.
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    inherit_external_notifications?: boolean;
    /**
     * Allow members of this workspace to invite users outside the workspace to become workspace members. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    invitations_allowed?: boolean;
    /**
     * Allow workspace managers of this workspace to invite users outside the workspace to become workspace members. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    invitations_allowed_by_managers?: boolean;
    /**
     * The user is a workspace manager user type. RESPONSE User scope if is_workspace_membership.
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    manager?: boolean;
    /**
     * The ID of the group containing all manager of this workspace. RESPONSE User scope. RESPONSE Admin scope (org admin).
     * @type {number}
     * @memberof WorkspacesResponse
     */
    managers_group_id?: number;
    /**
     * The user is part of the workspace. RESPONSE User scope. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    member?: boolean;
    /**
     * The workspace name. Query parameter for GET method. POST Admin permission required. PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesResponse
     */
    name?: string;
    /**
     * The ID of the node on which workspace folders and packages are stored. Query parameter for GET method. POST Admin permission required. PUT Manager permission required.
     * @type {number}
     * @memberof WorkspacesResponse
     */
    node_id?: number;
    /**
     * Whether or not package download counts are recorded. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    package_download_counts_enabled?: boolean;
    /**
     * Enable members of this workspace to configure personalized URLs to send when inviting people to submit packages (refer to public_links_allowed). You can set this parameter to true only if url_shortening_enabled is also set to true. Once you enable personalized URLs, you enable a default personalized URL construction and you also allow workspace member to configure the URLs they send. The default URL configuration contains the sender\'s username or the dropbox name; for example: https://aspera.pub/John_Doe;https://aspera.pub/Dropbox1. Note that dropboxes in the workspace inherit the settings you configure for the workspace as follows: When short URLs are enabled at the workspace (url_shortening_enabled=true): Short URLs are enabled for all dropboxes in that workspace. You cannot disable short URLs for a dropbox. When personalized URLs are enabled at the workspace: Personalized URLs are enabled for all dropboxes in that workspace. You can disable personalized URLs for specific dropboxes if desired. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required.
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    personalized_urls_enabled?: boolean;
    /**
     * Allow workspace members to send invitations to users outside the workspace, inviting them to send a package to (1) the user who issues the invitation, and (2) the dropboxes in which the user who issues the invitation is a member. An outside user can be a person who is a member of a different AoC workspace, or a person without an AoC account. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required.
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    public_invites_allowed?: boolean;
    /**
     * Allow workspace managers to send invitations to users outside the workspace, inviting them to send a package to (1) the workspace manager who issues the invitation, and (2) the dropboxes in which the workspace manager is a member. An outside user can be a person who is a member of a different AoC workspace, or a person without an AoC account. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    public_invites_allowed_by_managers?: boolean;
    /**
     * Allow users in the workspace to send a link to users outside the workspace, allowing them to access a file or folder that the inviter has access to in the workspace. An outside user can be a person who is a member of a different AoC workspace, or a person without an AoC account. The inviter must have proper permission to the file or folder being shared. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    public_links_allowed?: boolean;
    /**
     * Allow workspace managers to send a link to users outside the workspace, allowing them to access a file or folder that the inviter has access to in the workspace. An outside user can be a person who is a member of a different AoC workspace, or a person without an AoC account. The inviter must have proper permission to the file or folder being shared. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    public_links_allowed_by_managers?: boolean;
    /**
     * The file ID of the root folder containing packages for this workspace. POST Admin permission required. PUT Manager permission required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesResponse
     */
    root_file_id?: string;
    /**
     * Where packages are stored POST Admin permission required. PUT Manager permission required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesResponse
     */
    spool_file_id?: string;
    /**
     * Whether or not the users of this workspace can upload to their respective home folders. Set this parameter to false to prevent users from uploading to or creating new folders in their home folders. Restricting these functions is one way to control storage usage in the workspace. To exempt certain workspace members from this restriction, set storage_allowed to true for those members in /workspace_memberships. POST Admin permission required. PUT Admin permission required. RESPONSE User scope. RESPONSE Admin scope (could be ws manager). RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    storage_allowed?: boolean;
    /**
     * datetime RESPONSE User scope. RESPONSE Admin scope (org admin).
     * @type {string}
     * @memberof WorkspacesResponse
     */
    updated_at?: string;
    /**
     * When members of this workspace send a link that allows the recipient to send a package (refer to public_invites_allowed), the link generated will have the shortened form; for example:  (compared to the standard URL; for example: ). When this parameter is set to true, you can also set personalized_urls_enabled to true. POST Admin permission required. PUT Manager permission and collaboration settings editable by managers required or PUT Admin permission required. RESPONSE Admin scope (org admin).
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    url_shortening_enabled?: boolean;
    /**
     * RESPONSE User scope if is_workspace_membership.
     * @type {number}
     * @memberof WorkspacesResponse
     */
    user_id?: number;
    /**
     * Enable watermarking on the workspace. Admin Only.
     * @type {boolean}
     * @memberof WorkspacesResponse
     */
    watermark?: boolean;
}

/**
 * AppsAppMembershipsApi - axios parameter creator
 * @export
 */
export const AppsAppMembershipsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an app membership. Requires organization admin permission.
         * @summary add_app_membership
         * @param {AsperaAppType} asperaAppType 
         * @param {AppMembershipsParams} appMembershipsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAppMembership: async (asperaAppType: AsperaAppType, appMembershipsParams: AppMembershipsParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'asperaAppType' is not null or undefined
            assertParamExists('addAppMembership', 'asperaAppType', asperaAppType)
            // verify required parameter 'appMembershipsParams' is not null or undefined
            assertParamExists('addAppMembership', 'appMembershipsParams', appMembershipsParams)
            const localVarPath = `/apps/{aspera_app_type}/app_memberships`
                .replace(`{${"aspera_app_type"}}`, encodeURIComponent(String(asperaAppType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appMembershipsParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an app membership, specified by membership ID. Requires organization admin permission.
         * @summary delete_app_membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppMembership: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAppMembership', 'id', id)
            const localVarPath = `/apps/app_memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a specific app membership, specified by membership ID.
         * @summary get_app_membership_by_id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppMembershipById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAppMembershipById', 'id', id)
            const localVarPath = `/apps/app_memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a listing of app memberships. For organization admins, all app memberships for the entire organization are available to view. For all other users, your own app memberships are available.
         * @summary get_app_memberships
         * @param {string} [asperaAppType] Allowable values are activity or automation.
         * @param {string} [createdAt] 
         * @param {boolean} [inherited] By default, returns inherited memberships. Set to false if you want to filter out inherited memberships.
         * @param {string} [lastLoginAt] 
         * @param {string} [memberEmail] For member_type&#x3D;user
         * @param {string} [memberName] For member_type&#x3D;user.
         * @param {string} [memberType] Can be \&quot;user\&quot; or \&quot;group\&quot;.
         * @param {string} [q] Searches member.email and member.name.
         * @param {string} [sort] Specify a field for sorting results.
         * @param {string} [updatedAt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppMemberships: async (asperaAppType?: string, createdAt?: string, inherited?: boolean, lastLoginAt?: string, memberEmail?: string, memberName?: string, memberType?: string, q?: string, sort?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/apps/app_memberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (asperaAppType !== undefined) {
                localVarQueryParameter['aspera_app_type'] = asperaAppType;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = (createdAt as any instanceof Date) ?
                    (createdAt as any).toISOString() :
                    createdAt;
            }

            if (inherited !== undefined) {
                localVarQueryParameter['inherited'] = inherited;
            }

            if (lastLoginAt !== undefined) {
                localVarQueryParameter['last_login_at'] = (lastLoginAt as any instanceof Date) ?
                    (lastLoginAt as any).toISOString() :
                    lastLoginAt;
            }

            if (memberEmail !== undefined) {
                localVarQueryParameter['member.email'] = memberEmail;
            }

            if (memberName !== undefined) {
                localVarQueryParameter['member.name'] = memberName;
            }

            if (memberType !== undefined) {
                localVarQueryParameter['member_type'] = memberType;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = (updatedAt as any instanceof Date) ?
                    (updatedAt as any).toISOString() :
                    updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppsAppMembershipsApi - functional programming interface
 * @export
 */
export const AppsAppMembershipsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppsAppMembershipsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an app membership. Requires organization admin permission.
         * @summary add_app_membership
         * @param {AsperaAppType} asperaAppType 
         * @param {AppMembershipsParams} appMembershipsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAppMembership(asperaAppType: AsperaAppType, appMembershipsParams: AppMembershipsParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppMembershipsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAppMembership(asperaAppType, appMembershipsParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an app membership, specified by membership ID. Requires organization admin permission.
         * @summary delete_app_membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAppMembership(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAppMembership(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about a specific app membership, specified by membership ID.
         * @summary get_app_membership_by_id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAppMembershipById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppMembershipsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAppMembershipById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a listing of app memberships. For organization admins, all app memberships for the entire organization are available to view. For all other users, your own app memberships are available.
         * @summary get_app_memberships
         * @param {string} [asperaAppType] Allowable values are activity or automation.
         * @param {string} [createdAt] 
         * @param {boolean} [inherited] By default, returns inherited memberships. Set to false if you want to filter out inherited memberships.
         * @param {string} [lastLoginAt] 
         * @param {string} [memberEmail] For member_type&#x3D;user
         * @param {string} [memberName] For member_type&#x3D;user.
         * @param {string} [memberType] Can be \&quot;user\&quot; or \&quot;group\&quot;.
         * @param {string} [q] Searches member.email and member.name.
         * @param {string} [sort] Specify a field for sorting results.
         * @param {string} [updatedAt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAppMemberships(asperaAppType?: string, createdAt?: string, inherited?: boolean, lastLoginAt?: string, memberEmail?: string, memberName?: string, memberType?: string, q?: string, sort?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AppMembershipsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAppMemberships(asperaAppType, createdAt, inherited, lastLoginAt, memberEmail, memberName, memberType, q, sort, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AppsAppMembershipsApi - factory interface
 * @export
 */
export const AppsAppMembershipsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppsAppMembershipsApiFp(configuration)
    return {
        /**
         * Create an app membership. Requires organization admin permission.
         * @summary add_app_membership
         * @param {AsperaAppType} asperaAppType 
         * @param {AppMembershipsParams} appMembershipsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAppMembership(asperaAppType: AsperaAppType, appMembershipsParams: AppMembershipsParams, options?: any): AxiosPromise<AppMembershipsResponse> {
            return localVarFp.addAppMembership(asperaAppType, appMembershipsParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an app membership, specified by membership ID. Requires organization admin permission.
         * @summary delete_app_membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppMembership(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAppMembership(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a specific app membership, specified by membership ID.
         * @summary get_app_membership_by_id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppMembershipById(id: string, options?: any): AxiosPromise<AppMembershipsResponse> {
            return localVarFp.getAppMembershipById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a listing of app memberships. For organization admins, all app memberships for the entire organization are available to view. For all other users, your own app memberships are available.
         * @summary get_app_memberships
         * @param {string} [asperaAppType] Allowable values are activity or automation.
         * @param {string} [createdAt] 
         * @param {boolean} [inherited] By default, returns inherited memberships. Set to false if you want to filter out inherited memberships.
         * @param {string} [lastLoginAt] 
         * @param {string} [memberEmail] For member_type&#x3D;user
         * @param {string} [memberName] For member_type&#x3D;user.
         * @param {string} [memberType] Can be \&quot;user\&quot; or \&quot;group\&quot;.
         * @param {string} [q] Searches member.email and member.name.
         * @param {string} [sort] Specify a field for sorting results.
         * @param {string} [updatedAt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppMemberships(asperaAppType?: string, createdAt?: string, inherited?: boolean, lastLoginAt?: string, memberEmail?: string, memberName?: string, memberType?: string, q?: string, sort?: string, updatedAt?: string, options?: any): AxiosPromise<Array<AppMembershipsResponse>> {
            return localVarFp.getAppMemberships(asperaAppType, createdAt, inherited, lastLoginAt, memberEmail, memberName, memberType, q, sort, updatedAt, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addAppMembership operation in AppsAppMembershipsApi.
 * @export
 * @interface AppsAppMembershipsApiAddAppMembershipRequest
 */
export interface AppsAppMembershipsApiAddAppMembershipRequest {
    /**
     * 
     * @type {AsperaAppType}
     * @memberof AppsAppMembershipsApiAddAppMembership
     */
    readonly asperaAppType: AsperaAppType

    /**
     * 
     * @type {AppMembershipsParams}
     * @memberof AppsAppMembershipsApiAddAppMembership
     */
    readonly appMembershipsParams: AppMembershipsParams
}

/**
 * Request parameters for deleteAppMembership operation in AppsAppMembershipsApi.
 * @export
 * @interface AppsAppMembershipsApiDeleteAppMembershipRequest
 */
export interface AppsAppMembershipsApiDeleteAppMembershipRequest {
    /**
     * 
     * @type {string}
     * @memberof AppsAppMembershipsApiDeleteAppMembership
     */
    readonly id: string
}

/**
 * Request parameters for getAppMembershipById operation in AppsAppMembershipsApi.
 * @export
 * @interface AppsAppMembershipsApiGetAppMembershipByIdRequest
 */
export interface AppsAppMembershipsApiGetAppMembershipByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof AppsAppMembershipsApiGetAppMembershipById
     */
    readonly id: string
}

/**
 * Request parameters for getAppMemberships operation in AppsAppMembershipsApi.
 * @export
 * @interface AppsAppMembershipsApiGetAppMembershipsRequest
 */
export interface AppsAppMembershipsApiGetAppMembershipsRequest {
    /**
     * Allowable values are activity or automation.
     * @type {string}
     * @memberof AppsAppMembershipsApiGetAppMemberships
     */
    readonly asperaAppType?: string

    /**
     * 
     * @type {string}
     * @memberof AppsAppMembershipsApiGetAppMemberships
     */
    readonly createdAt?: string

    /**
     * By default, returns inherited memberships. Set to false if you want to filter out inherited memberships.
     * @type {boolean}
     * @memberof AppsAppMembershipsApiGetAppMemberships
     */
    readonly inherited?: boolean

    /**
     * 
     * @type {string}
     * @memberof AppsAppMembershipsApiGetAppMemberships
     */
    readonly lastLoginAt?: string

    /**
     * For member_type&#x3D;user
     * @type {string}
     * @memberof AppsAppMembershipsApiGetAppMemberships
     */
    readonly memberEmail?: string

    /**
     * For member_type&#x3D;user.
     * @type {string}
     * @memberof AppsAppMembershipsApiGetAppMemberships
     */
    readonly memberName?: string

    /**
     * Can be \&quot;user\&quot; or \&quot;group\&quot;.
     * @type {string}
     * @memberof AppsAppMembershipsApiGetAppMemberships
     */
    readonly memberType?: string

    /**
     * Searches member.email and member.name.
     * @type {string}
     * @memberof AppsAppMembershipsApiGetAppMemberships
     */
    readonly q?: string

    /**
     * Specify a field for sorting results.
     * @type {string}
     * @memberof AppsAppMembershipsApiGetAppMemberships
     */
    readonly sort?: string

    /**
     * 
     * @type {string}
     * @memberof AppsAppMembershipsApiGetAppMemberships
     */
    readonly updatedAt?: string
}

/**
 * AppsAppMembershipsApi - object-oriented interface
 * @export
 * @class AppsAppMembershipsApi
 * @extends {BaseAPI}
 */
export class AppsAppMembershipsApi extends BaseAPI {
    /**
     * Create an app membership. Requires organization admin permission.
     * @summary add_app_membership
     * @param {AppsAppMembershipsApiAddAppMembershipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsAppMembershipsApi
     */
    public addAppMembership(requestParameters: AppsAppMembershipsApiAddAppMembershipRequest, options?: any) {
        return AppsAppMembershipsApiFp(this.configuration).addAppMembership(requestParameters.asperaAppType, requestParameters.appMembershipsParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an app membership, specified by membership ID. Requires organization admin permission.
     * @summary delete_app_membership
     * @param {AppsAppMembershipsApiDeleteAppMembershipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsAppMembershipsApi
     */
    public deleteAppMembership(requestParameters: AppsAppMembershipsApiDeleteAppMembershipRequest, options?: any) {
        return AppsAppMembershipsApiFp(this.configuration).deleteAppMembership(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a specific app membership, specified by membership ID.
     * @summary get_app_membership_by_id
     * @param {AppsAppMembershipsApiGetAppMembershipByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsAppMembershipsApi
     */
    public getAppMembershipById(requestParameters: AppsAppMembershipsApiGetAppMembershipByIdRequest, options?: any) {
        return AppsAppMembershipsApiFp(this.configuration).getAppMembershipById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a listing of app memberships. For organization admins, all app memberships for the entire organization are available to view. For all other users, your own app memberships are available.
     * @summary get_app_memberships
     * @param {AppsAppMembershipsApiGetAppMembershipsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsAppMembershipsApi
     */
    public getAppMemberships(requestParameters: AppsAppMembershipsApiGetAppMembershipsRequest = {}, options?: any) {
        return AppsAppMembershipsApiFp(this.configuration).getAppMemberships(requestParameters.asperaAppType, requestParameters.createdAt, requestParameters.inherited, requestParameters.lastLoginAt, requestParameters.memberEmail, requestParameters.memberName, requestParameters.memberType, requestParameters.q, requestParameters.sort, requestParameters.updatedAt, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AppsNewPackagesApi - axios parameter creator
 * @export
 */
export const AppsNewPackagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the organizational or workspace settings of the Packages application in AoC
         * @summary Update the settings of the Packages app
         * @param {string} appId The ID for the organization-level or workspace-level Packages app.
         * @param {AppsNewPackagesRequest} appsNewPackagesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatethesettingsofthePackagesapp: async (appId: string, appsNewPackagesRequest: AppsNewPackagesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updatethesettingsofthePackagesapp', 'appId', appId)
            // verify required parameter 'appsNewPackagesRequest' is not null or undefined
            assertParamExists('updatethesettingsofthePackagesapp', 'appsNewPackagesRequest', appsNewPackagesRequest)
            const localVarPath = `/apps_new/packages/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appsNewPackagesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppsNewPackagesApi - functional programming interface
 * @export
 */
export const AppsNewPackagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppsNewPackagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the organizational or workspace settings of the Packages application in AoC
         * @summary Update the settings of the Packages app
         * @param {string} appId The ID for the organization-level or workspace-level Packages app.
         * @param {AppsNewPackagesRequest} appsNewPackagesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatethesettingsofthePackagesapp(appId: string, appsNewPackagesRequest: AppsNewPackagesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatethesettingsofthePackagesapp(appId, appsNewPackagesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AppsNewPackagesApi - factory interface
 * @export
 */
export const AppsNewPackagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppsNewPackagesApiFp(configuration)
    return {
        /**
         * Update the organizational or workspace settings of the Packages application in AoC
         * @summary Update the settings of the Packages app
         * @param {string} appId The ID for the organization-level or workspace-level Packages app.
         * @param {AppsNewPackagesRequest} appsNewPackagesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatethesettingsofthePackagesapp(appId: string, appsNewPackagesRequest: AppsNewPackagesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updatethesettingsofthePackagesapp(appId, appsNewPackagesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updatethesettingsofthePackagesapp operation in AppsNewPackagesApi.
 * @export
 * @interface AppsNewPackagesApiUpdatethesettingsofthePackagesappRequest
 */
export interface AppsNewPackagesApiUpdatethesettingsofthePackagesappRequest {
    /**
     * The ID for the organization-level or workspace-level Packages app.
     * @type {string}
     * @memberof AppsNewPackagesApiUpdatethesettingsofthePackagesapp
     */
    readonly appId: string

    /**
     * 
     * @type {AppsNewPackagesRequest}
     * @memberof AppsNewPackagesApiUpdatethesettingsofthePackagesapp
     */
    readonly appsNewPackagesRequest: AppsNewPackagesRequest
}

/**
 * AppsNewPackagesApi - object-oriented interface
 * @export
 * @class AppsNewPackagesApi
 * @extends {BaseAPI}
 */
export class AppsNewPackagesApi extends BaseAPI {
    /**
     * Update the organizational or workspace settings of the Packages application in AoC
     * @summary Update the settings of the Packages app
     * @param {AppsNewPackagesApiUpdatethesettingsofthePackagesappRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsNewPackagesApi
     */
    public updatethesettingsofthePackagesapp(requestParameters: AppsNewPackagesApiUpdatethesettingsofthePackagesappRequest, options?: any) {
        return AppsNewPackagesApiFp(this.configuration).updatethesettingsofthePackagesapp(requestParameters.appId, requestParameters.appsNewPackagesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClientAccessKeysApi - axios parameter creator
 * @export
 */
export const ClientAccessKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a client access key
         * @summary add_client_access_key
         * @param {ClientAccessKeysParams} clientAccessKeysParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addClientAccessKey: async (clientAccessKeysParams: ClientAccessKeysParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientAccessKeysParams' is not null or undefined
            assertParamExists('addClientAccessKey', 'clientAccessKeysParams', clientAccessKeysParams)
            const localVarPath = `/client_access_keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientAccessKeysParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a client access key, specified by id.
         * @summary delete_client_access_key
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClientAccessKey: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteClientAccessKey', 'id', id)
            const localVarPath = `/client_access_keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about specific client access key, specified by id.
         * @summary get_client_access_key_by_id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientAccessKeyById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getClientAccessKeyById', 'id', id)
            const localVarPath = `/client_access_keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a listing of client access keys for your organization.
         * @summary get_client_access_keys
         * @param {string} [nodeId] 
         * @param {string} [rootFileId] 
         * @param {string} [permissionId] 
         * @param {string} [workspaceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientAccessKeys: async (nodeId?: string, rootFileId?: string, permissionId?: string, workspaceId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/client_access_keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nodeId !== undefined) {
                localVarQueryParameter['node_id'] = nodeId;
            }

            if (rootFileId !== undefined) {
                localVarQueryParameter['root_file_id'] = rootFileId;
            }

            if (permissionId !== undefined) {
                localVarQueryParameter['permission_id'] = permissionId;
            }

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the name of a client access key.
         * @summary Update the Name of a Client Access Key
         * @param {string} id 
         * @param {ClientAccessKeysRequest} clientAccessKeysRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatetheNameofaClientAccessKey: async (id: string, clientAccessKeysRequest: ClientAccessKeysRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatetheNameofaClientAccessKey', 'id', id)
            // verify required parameter 'clientAccessKeysRequest' is not null or undefined
            assertParamExists('updatetheNameofaClientAccessKey', 'clientAccessKeysRequest', clientAccessKeysRequest)
            const localVarPath = `/client_access_keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientAccessKeysRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientAccessKeysApi - functional programming interface
 * @export
 */
export const ClientAccessKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientAccessKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a client access key
         * @summary add_client_access_key
         * @param {ClientAccessKeysParams} clientAccessKeysParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addClientAccessKey(clientAccessKeysParams: ClientAccessKeysParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientAccessKeysResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addClientAccessKey(clientAccessKeysParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a client access key, specified by id.
         * @summary delete_client_access_key
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClientAccessKey(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClientAccessKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about specific client access key, specified by id.
         * @summary get_client_access_key_by_id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientAccessKeyById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientAccessKeysResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientAccessKeyById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a listing of client access keys for your organization.
         * @summary get_client_access_keys
         * @param {string} [nodeId] 
         * @param {string} [rootFileId] 
         * @param {string} [permissionId] 
         * @param {string} [workspaceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientAccessKeys(nodeId?: string, rootFileId?: string, permissionId?: string, workspaceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClientAccessKeysResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientAccessKeys(nodeId, rootFileId, permissionId, workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the name of a client access key.
         * @summary Update the Name of a Client Access Key
         * @param {string} id 
         * @param {ClientAccessKeysRequest} clientAccessKeysRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatetheNameofaClientAccessKey(id: string, clientAccessKeysRequest: ClientAccessKeysRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatetheNameofaClientAccessKey(id, clientAccessKeysRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClientAccessKeysApi - factory interface
 * @export
 */
export const ClientAccessKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientAccessKeysApiFp(configuration)
    return {
        /**
         * Create a client access key
         * @summary add_client_access_key
         * @param {ClientAccessKeysParams} clientAccessKeysParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addClientAccessKey(clientAccessKeysParams: ClientAccessKeysParams, options?: any): AxiosPromise<ClientAccessKeysResponse> {
            return localVarFp.addClientAccessKey(clientAccessKeysParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a client access key, specified by id.
         * @summary delete_client_access_key
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClientAccessKey(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteClientAccessKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about specific client access key, specified by id.
         * @summary get_client_access_key_by_id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientAccessKeyById(id: string, options?: any): AxiosPromise<ClientAccessKeysResponse> {
            return localVarFp.getClientAccessKeyById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a listing of client access keys for your organization.
         * @summary get_client_access_keys
         * @param {string} [nodeId] 
         * @param {string} [rootFileId] 
         * @param {string} [permissionId] 
         * @param {string} [workspaceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientAccessKeys(nodeId?: string, rootFileId?: string, permissionId?: string, workspaceId?: string, options?: any): AxiosPromise<Array<ClientAccessKeysResponse>> {
            return localVarFp.getClientAccessKeys(nodeId, rootFileId, permissionId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the name of a client access key.
         * @summary Update the Name of a Client Access Key
         * @param {string} id 
         * @param {ClientAccessKeysRequest} clientAccessKeysRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatetheNameofaClientAccessKey(id: string, clientAccessKeysRequest: ClientAccessKeysRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updatetheNameofaClientAccessKey(id, clientAccessKeysRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addClientAccessKey operation in ClientAccessKeysApi.
 * @export
 * @interface ClientAccessKeysApiAddClientAccessKeyRequest
 */
export interface ClientAccessKeysApiAddClientAccessKeyRequest {
    /**
     * 
     * @type {ClientAccessKeysParams}
     * @memberof ClientAccessKeysApiAddClientAccessKey
     */
    readonly clientAccessKeysParams: ClientAccessKeysParams
}

/**
 * Request parameters for deleteClientAccessKey operation in ClientAccessKeysApi.
 * @export
 * @interface ClientAccessKeysApiDeleteClientAccessKeyRequest
 */
export interface ClientAccessKeysApiDeleteClientAccessKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientAccessKeysApiDeleteClientAccessKey
     */
    readonly id: string
}

/**
 * Request parameters for getClientAccessKeyById operation in ClientAccessKeysApi.
 * @export
 * @interface ClientAccessKeysApiGetClientAccessKeyByIdRequest
 */
export interface ClientAccessKeysApiGetClientAccessKeyByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientAccessKeysApiGetClientAccessKeyById
     */
    readonly id: string
}

/**
 * Request parameters for getClientAccessKeys operation in ClientAccessKeysApi.
 * @export
 * @interface ClientAccessKeysApiGetClientAccessKeysRequest
 */
export interface ClientAccessKeysApiGetClientAccessKeysRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientAccessKeysApiGetClientAccessKeys
     */
    readonly nodeId?: string

    /**
     * 
     * @type {string}
     * @memberof ClientAccessKeysApiGetClientAccessKeys
     */
    readonly rootFileId?: string

    /**
     * 
     * @type {string}
     * @memberof ClientAccessKeysApiGetClientAccessKeys
     */
    readonly permissionId?: string

    /**
     * 
     * @type {string}
     * @memberof ClientAccessKeysApiGetClientAccessKeys
     */
    readonly workspaceId?: string
}

/**
 * Request parameters for updatetheNameofaClientAccessKey operation in ClientAccessKeysApi.
 * @export
 * @interface ClientAccessKeysApiUpdatetheNameofaClientAccessKeyRequest
 */
export interface ClientAccessKeysApiUpdatetheNameofaClientAccessKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientAccessKeysApiUpdatetheNameofaClientAccessKey
     */
    readonly id: string

    /**
     * 
     * @type {ClientAccessKeysRequest}
     * @memberof ClientAccessKeysApiUpdatetheNameofaClientAccessKey
     */
    readonly clientAccessKeysRequest: ClientAccessKeysRequest
}

/**
 * ClientAccessKeysApi - object-oriented interface
 * @export
 * @class ClientAccessKeysApi
 * @extends {BaseAPI}
 */
export class ClientAccessKeysApi extends BaseAPI {
    /**
     * Create a client access key
     * @summary add_client_access_key
     * @param {ClientAccessKeysApiAddClientAccessKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientAccessKeysApi
     */
    public addClientAccessKey(requestParameters: ClientAccessKeysApiAddClientAccessKeyRequest, options?: any) {
        return ClientAccessKeysApiFp(this.configuration).addClientAccessKey(requestParameters.clientAccessKeysParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a client access key, specified by id.
     * @summary delete_client_access_key
     * @param {ClientAccessKeysApiDeleteClientAccessKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientAccessKeysApi
     */
    public deleteClientAccessKey(requestParameters: ClientAccessKeysApiDeleteClientAccessKeyRequest, options?: any) {
        return ClientAccessKeysApiFp(this.configuration).deleteClientAccessKey(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about specific client access key, specified by id.
     * @summary get_client_access_key_by_id
     * @param {ClientAccessKeysApiGetClientAccessKeyByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientAccessKeysApi
     */
    public getClientAccessKeyById(requestParameters: ClientAccessKeysApiGetClientAccessKeyByIdRequest, options?: any) {
        return ClientAccessKeysApiFp(this.configuration).getClientAccessKeyById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a listing of client access keys for your organization.
     * @summary get_client_access_keys
     * @param {ClientAccessKeysApiGetClientAccessKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientAccessKeysApi
     */
    public getClientAccessKeys(requestParameters: ClientAccessKeysApiGetClientAccessKeysRequest = {}, options?: any) {
        return ClientAccessKeysApiFp(this.configuration).getClientAccessKeys(requestParameters.nodeId, requestParameters.rootFileId, requestParameters.permissionId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the name of a client access key.
     * @summary Update the Name of a Client Access Key
     * @param {ClientAccessKeysApiUpdatetheNameofaClientAccessKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientAccessKeysApi
     */
    public updatetheNameofaClientAccessKey(requestParameters: ClientAccessKeysApiUpdatetheNameofaClientAccessKeyRequest, options?: any) {
        return ClientAccessKeysApiFp(this.configuration).updatetheNameofaClientAccessKey(requestParameters.id, requestParameters.clientAccessKeysRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClientAuthorizationsApi - axios parameter creator
 * @export
 */
export const ClientAuthorizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an authorization for an API client. Each entity to authorize requires a separate request.
         * @summary add_client_authorization
         * @param {ClientAuthorizationsParams} clientAuthorizationsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addClientAuthorization: async (clientAuthorizationsParams: ClientAuthorizationsParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientAuthorizationsParams' is not null or undefined
            assertParamExists('addClientAuthorization', 'clientAuthorizationsParams', clientAuthorizationsParams)
            const localVarPath = `/client_authorizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientAuthorizationsParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user from a client whitelist.
         * @summary delete_client_authorization
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClientAuthorization: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteClientAuthorization', 'id', id)
            const localVarPath = `/client_authorizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a listing with information on all entities in the whitelist for a specific client.
         * @summary get_client_authorization_by_id
         * @param {string} id 
         * @param {string} [embed] embed[]&#x3D;entity (gives back entity which should be user/group)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientAuthorizationById: async (id: string, embed?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getClientAuthorizationById', 'id', id)
            const localVarPath = `/client_authorizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (embed !== undefined) {
                localVarQueryParameter['embed[]'] = embed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a listing of information on all client whitelists.
         * @summary get_client_authorizations
         * @param {string} [clientId] 
         * @param {string} [entityId] 
         * @param {string} [entityType] 
         * @param {string} [embed] embed[]&#x3D;entity (gives back entity which should be user/group)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientAuthorizations: async (clientId?: string, entityId?: string, entityType?: string, embed?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/client_authorizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }

            if (entityId !== undefined) {
                localVarQueryParameter['entity_id'] = entityId;
            }

            if (entityType !== undefined) {
                localVarQueryParameter['entity_type'] = entityType;
            }

            if (embed !== undefined) {
                localVarQueryParameter['embed[]'] = embed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientAuthorizationsApi - functional programming interface
 * @export
 */
export const ClientAuthorizationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientAuthorizationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an authorization for an API client. Each entity to authorize requires a separate request.
         * @summary add_client_authorization
         * @param {ClientAuthorizationsParams} clientAuthorizationsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addClientAuthorization(clientAuthorizationsParams: ClientAuthorizationsParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientAuthorizationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addClientAuthorization(clientAuthorizationsParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a user from a client whitelist.
         * @summary delete_client_authorization
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClientAuthorization(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClientAuthorization(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a listing with information on all entities in the whitelist for a specific client.
         * @summary get_client_authorization_by_id
         * @param {string} id 
         * @param {string} [embed] embed[]&#x3D;entity (gives back entity which should be user/group)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientAuthorizationById(id: string, embed?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientAuthorizationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientAuthorizationById(id, embed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a listing of information on all client whitelists.
         * @summary get_client_authorizations
         * @param {string} [clientId] 
         * @param {string} [entityId] 
         * @param {string} [entityType] 
         * @param {string} [embed] embed[]&#x3D;entity (gives back entity which should be user/group)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientAuthorizations(clientId?: string, entityId?: string, entityType?: string, embed?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClientAuthorizationsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientAuthorizations(clientId, entityId, entityType, embed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClientAuthorizationsApi - factory interface
 * @export
 */
export const ClientAuthorizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientAuthorizationsApiFp(configuration)
    return {
        /**
         * Create an authorization for an API client. Each entity to authorize requires a separate request.
         * @summary add_client_authorization
         * @param {ClientAuthorizationsParams} clientAuthorizationsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addClientAuthorization(clientAuthorizationsParams: ClientAuthorizationsParams, options?: any): AxiosPromise<ClientAuthorizationsResponse> {
            return localVarFp.addClientAuthorization(clientAuthorizationsParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user from a client whitelist.
         * @summary delete_client_authorization
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClientAuthorization(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteClientAuthorization(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a listing with information on all entities in the whitelist for a specific client.
         * @summary get_client_authorization_by_id
         * @param {string} id 
         * @param {string} [embed] embed[]&#x3D;entity (gives back entity which should be user/group)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientAuthorizationById(id: string, embed?: string, options?: any): AxiosPromise<ClientAuthorizationsResponse> {
            return localVarFp.getClientAuthorizationById(id, embed, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a listing of information on all client whitelists.
         * @summary get_client_authorizations
         * @param {string} [clientId] 
         * @param {string} [entityId] 
         * @param {string} [entityType] 
         * @param {string} [embed] embed[]&#x3D;entity (gives back entity which should be user/group)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientAuthorizations(clientId?: string, entityId?: string, entityType?: string, embed?: string, options?: any): AxiosPromise<Array<ClientAuthorizationsResponse>> {
            return localVarFp.getClientAuthorizations(clientId, entityId, entityType, embed, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addClientAuthorization operation in ClientAuthorizationsApi.
 * @export
 * @interface ClientAuthorizationsApiAddClientAuthorizationRequest
 */
export interface ClientAuthorizationsApiAddClientAuthorizationRequest {
    /**
     * 
     * @type {ClientAuthorizationsParams}
     * @memberof ClientAuthorizationsApiAddClientAuthorization
     */
    readonly clientAuthorizationsParams: ClientAuthorizationsParams
}

/**
 * Request parameters for deleteClientAuthorization operation in ClientAuthorizationsApi.
 * @export
 * @interface ClientAuthorizationsApiDeleteClientAuthorizationRequest
 */
export interface ClientAuthorizationsApiDeleteClientAuthorizationRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientAuthorizationsApiDeleteClientAuthorization
     */
    readonly id: string
}

/**
 * Request parameters for getClientAuthorizationById operation in ClientAuthorizationsApi.
 * @export
 * @interface ClientAuthorizationsApiGetClientAuthorizationByIdRequest
 */
export interface ClientAuthorizationsApiGetClientAuthorizationByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientAuthorizationsApiGetClientAuthorizationById
     */
    readonly id: string

    /**
     * embed[]&#x3D;entity (gives back entity which should be user/group)
     * @type {string}
     * @memberof ClientAuthorizationsApiGetClientAuthorizationById
     */
    readonly embed?: string
}

/**
 * Request parameters for getClientAuthorizations operation in ClientAuthorizationsApi.
 * @export
 * @interface ClientAuthorizationsApiGetClientAuthorizationsRequest
 */
export interface ClientAuthorizationsApiGetClientAuthorizationsRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientAuthorizationsApiGetClientAuthorizations
     */
    readonly clientId?: string

    /**
     * 
     * @type {string}
     * @memberof ClientAuthorizationsApiGetClientAuthorizations
     */
    readonly entityId?: string

    /**
     * 
     * @type {string}
     * @memberof ClientAuthorizationsApiGetClientAuthorizations
     */
    readonly entityType?: string

    /**
     * embed[]&#x3D;entity (gives back entity which should be user/group)
     * @type {string}
     * @memberof ClientAuthorizationsApiGetClientAuthorizations
     */
    readonly embed?: string
}

/**
 * ClientAuthorizationsApi - object-oriented interface
 * @export
 * @class ClientAuthorizationsApi
 * @extends {BaseAPI}
 */
export class ClientAuthorizationsApi extends BaseAPI {
    /**
     * Create an authorization for an API client. Each entity to authorize requires a separate request.
     * @summary add_client_authorization
     * @param {ClientAuthorizationsApiAddClientAuthorizationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientAuthorizationsApi
     */
    public addClientAuthorization(requestParameters: ClientAuthorizationsApiAddClientAuthorizationRequest, options?: any) {
        return ClientAuthorizationsApiFp(this.configuration).addClientAuthorization(requestParameters.clientAuthorizationsParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user from a client whitelist.
     * @summary delete_client_authorization
     * @param {ClientAuthorizationsApiDeleteClientAuthorizationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientAuthorizationsApi
     */
    public deleteClientAuthorization(requestParameters: ClientAuthorizationsApiDeleteClientAuthorizationRequest, options?: any) {
        return ClientAuthorizationsApiFp(this.configuration).deleteClientAuthorization(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a listing with information on all entities in the whitelist for a specific client.
     * @summary get_client_authorization_by_id
     * @param {ClientAuthorizationsApiGetClientAuthorizationByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientAuthorizationsApi
     */
    public getClientAuthorizationById(requestParameters: ClientAuthorizationsApiGetClientAuthorizationByIdRequest, options?: any) {
        return ClientAuthorizationsApiFp(this.configuration).getClientAuthorizationById(requestParameters.id, requestParameters.embed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a listing of information on all client whitelists.
     * @summary get_client_authorizations
     * @param {ClientAuthorizationsApiGetClientAuthorizationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientAuthorizationsApi
     */
    public getClientAuthorizations(requestParameters: ClientAuthorizationsApiGetClientAuthorizationsRequest = {}, options?: any) {
        return ClientAuthorizationsApiFp(this.configuration).getClientAuthorizations(requestParameters.clientId, requestParameters.entityId, requestParameters.entityType, requestParameters.embed, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClientsApi - axios parameter creator
 * @export
 */
export const ClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an API client.
         * @summary add_client
         * @param {ClientsParams} clientsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addClient: async (clientsParams: ClientsParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientsParams' is not null or undefined
            assertParamExists('addClient', 'clientsParams', clientsParams)
            const localVarPath = `/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientsParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a registered client, specified by client ID.
         * @summary delete_client
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClient: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteClient', 'id', id)
            const localVarPath = `/clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a specific registered client, specified by the client ID returned in the GET response.
         * @summary get_client_by_id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getClientById', 'id', id)
            const localVarPath = `/clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a listing of clients currently registered to use the Aspera on Cloud API.
         * @summary get_clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClients: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a registered client. For example, change the redirect URI and the admin node token retrieval parameters.
         * @summary update_client
         * @param {string} id 
         * @param {ClientsParams} clientsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClient: async (id: string, clientsParams: ClientsParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateClient', 'id', id)
            // verify required parameter 'clientsParams' is not null or undefined
            assertParamExists('updateClient', 'clientsParams', clientsParams)
            const localVarPath = `/clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientsParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientsApi - functional programming interface
 * @export
 */
export const ClientsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an API client.
         * @summary add_client
         * @param {ClientsParams} clientsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addClient(clientsParams: ClientsParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addClient(clientsParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a registered client, specified by client ID.
         * @summary delete_client
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClient(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClient(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about a specific registered client, specified by the client ID returned in the GET response.
         * @summary get_client_by_id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a listing of clients currently registered to use the Aspera on Cloud API.
         * @summary get_clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClients(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClientsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClients(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a registered client. For example, change the redirect URI and the admin node token retrieval parameters.
         * @summary update_client
         * @param {string} id 
         * @param {ClientsParams} clientsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClient(id: string, clientsParams: ClientsParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateClient(id, clientsParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClientsApi - factory interface
 * @export
 */
export const ClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientsApiFp(configuration)
    return {
        /**
         * Create an API client.
         * @summary add_client
         * @param {ClientsParams} clientsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addClient(clientsParams: ClientsParams, options?: any): AxiosPromise<ClientsResponse> {
            return localVarFp.addClient(clientsParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a registered client, specified by client ID.
         * @summary delete_client
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClient(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteClient(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a specific registered client, specified by the client ID returned in the GET response.
         * @summary get_client_by_id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientById(id: string, options?: any): AxiosPromise<ClientsResponse> {
            return localVarFp.getClientById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a listing of clients currently registered to use the Aspera on Cloud API.
         * @summary get_clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClients(options?: any): AxiosPromise<Array<ClientsResponse>> {
            return localVarFp.getClients(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a registered client. For example, change the redirect URI and the admin node token retrieval parameters.
         * @summary update_client
         * @param {string} id 
         * @param {ClientsParams} clientsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClient(id: string, clientsParams: ClientsParams, options?: any): AxiosPromise<void> {
            return localVarFp.updateClient(id, clientsParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addClient operation in ClientsApi.
 * @export
 * @interface ClientsApiAddClientRequest
 */
export interface ClientsApiAddClientRequest {
    /**
     * 
     * @type {ClientsParams}
     * @memberof ClientsApiAddClient
     */
    readonly clientsParams: ClientsParams
}

/**
 * Request parameters for deleteClient operation in ClientsApi.
 * @export
 * @interface ClientsApiDeleteClientRequest
 */
export interface ClientsApiDeleteClientRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientsApiDeleteClient
     */
    readonly id: string
}

/**
 * Request parameters for getClientById operation in ClientsApi.
 * @export
 * @interface ClientsApiGetClientByIdRequest
 */
export interface ClientsApiGetClientByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientsApiGetClientById
     */
    readonly id: string
}

/**
 * Request parameters for updateClient operation in ClientsApi.
 * @export
 * @interface ClientsApiUpdateClientRequest
 */
export interface ClientsApiUpdateClientRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientsApiUpdateClient
     */
    readonly id: string

    /**
     * 
     * @type {ClientsParams}
     * @memberof ClientsApiUpdateClient
     */
    readonly clientsParams: ClientsParams
}

/**
 * ClientsApi - object-oriented interface
 * @export
 * @class ClientsApi
 * @extends {BaseAPI}
 */
export class ClientsApi extends BaseAPI {
    /**
     * Create an API client.
     * @summary add_client
     * @param {ClientsApiAddClientRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public addClient(requestParameters: ClientsApiAddClientRequest, options?: any) {
        return ClientsApiFp(this.configuration).addClient(requestParameters.clientsParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a registered client, specified by client ID.
     * @summary delete_client
     * @param {ClientsApiDeleteClientRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public deleteClient(requestParameters: ClientsApiDeleteClientRequest, options?: any) {
        return ClientsApiFp(this.configuration).deleteClient(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a specific registered client, specified by the client ID returned in the GET response.
     * @summary get_client_by_id
     * @param {ClientsApiGetClientByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public getClientById(requestParameters: ClientsApiGetClientByIdRequest, options?: any) {
        return ClientsApiFp(this.configuration).getClientById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a listing of clients currently registered to use the Aspera on Cloud API.
     * @summary get_clients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public getClients(options?: any) {
        return ClientsApiFp(this.configuration).getClients(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a registered client. For example, change the redirect URI and the admin node token retrieval parameters.
     * @summary update_client
     * @param {ClientsApiUpdateClientRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public updateClient(requestParameters: ClientsApiUpdateClientRequest, options?: any) {
        return ClientsApiFp(this.configuration).updateClient(requestParameters.id, requestParameters.clientsParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DropboxMembershipsApi - axios parameter creator
 * @export
 */
export const DropboxMembershipsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a user or group as a member of this dropbox.
         * @summary Add a Dropbox Member
         * @param {DropboxMembershipsParams} dropboxMembershipsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addaDropboxMember: async (dropboxMembershipsParams: DropboxMembershipsParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dropboxMembershipsParams' is not null or undefined
            assertParamExists('addaDropboxMember', 'dropboxMembershipsParams', dropboxMembershipsParams)
            const localVarPath = `/dropbox_memberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dropboxMembershipsParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a listing of information about the current members of a given dropbox.
         * @summary get_dropbox_memberships
         * @param {boolean} [canInviteSubmitters] 
         * @param {boolean} [canReceivePackages] 
         * @param {boolean} [canSubmitPackages] 
         * @param {string} [createdAt] 
         * @param {string} [creatorId] 
         * @param {boolean} [deactivated] Filters memberships with member_type &#x3D; \&quot;user\&quot; by their \&quot;deactivated\&quot; attribute.
         * @param {string} [dropboxId] 
         * @param {string} [embed5B5D] embed%5B%5D&#x3D;member (user or group object from member_id), embed%5B%5D&#x3D;dropbox (dropbox object from dropbox_id)
         * @param {boolean} [inherited] Specifies whether or not to include inherited memberships in the response. Typically used when an admin is looking at the memberships for a particular member_id or when a user is looking at their own memberships.
         * @param {boolean} [manager] 
         * @param {string} [memberEmail] 
         * @param {string} [memberLastLoginAt] 
         * @param {string} [memberLastName] 
         * @param {boolean} [memberSystemGroup] 
         * @param {string} [memberId] 
         * @param {string} [memberType] Either \&quot;user\&quot; or \&quot;group\&quot;
         * @param {string} [q] Search member.email, member.first_name, member.last_name, and member.name.
         * @param {string} [updatedAt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDropboxMemberships: async (canInviteSubmitters?: boolean, canReceivePackages?: boolean, canSubmitPackages?: boolean, createdAt?: string, creatorId?: string, deactivated?: boolean, dropboxId?: string, embed5B5D?: string, inherited?: boolean, manager?: boolean, memberEmail?: string, memberLastLoginAt?: string, memberLastName?: string, memberSystemGroup?: boolean, memberId?: string, memberType?: string, q?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dropbox_memberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (canInviteSubmitters !== undefined) {
                localVarQueryParameter['can_invite_submitters'] = canInviteSubmitters;
            }

            if (canReceivePackages !== undefined) {
                localVarQueryParameter['can_receive_packages'] = canReceivePackages;
            }

            if (canSubmitPackages !== undefined) {
                localVarQueryParameter['can_submit_packages'] = canSubmitPackages;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = (createdAt as any instanceof Date) ?
                    (createdAt as any).toISOString() :
                    createdAt;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creator_id'] = creatorId;
            }

            if (deactivated !== undefined) {
                localVarQueryParameter['deactivated'] = deactivated;
            }

            if (dropboxId !== undefined) {
                localVarQueryParameter['dropbox_id'] = dropboxId;
            }

            if (embed5B5D !== undefined) {
                localVarQueryParameter['embed%5B%5D'] = embed5B5D;
            }

            if (inherited !== undefined) {
                localVarQueryParameter['inherited'] = inherited;
            }

            if (manager !== undefined) {
                localVarQueryParameter['manager'] = manager;
            }

            if (memberEmail !== undefined) {
                localVarQueryParameter['member.email'] = memberEmail;
            }

            if (memberLastLoginAt !== undefined) {
                localVarQueryParameter['member.last_login_at'] = (memberLastLoginAt as any instanceof Date) ?
                    (memberLastLoginAt as any).toISOString() :
                    memberLastLoginAt;
            }

            if (memberLastName !== undefined) {
                localVarQueryParameter['member.last_name'] = memberLastName;
            }

            if (memberSystemGroup !== undefined) {
                localVarQueryParameter['member.system_group'] = memberSystemGroup;
            }

            if (memberId !== undefined) {
                localVarQueryParameter['member_id'] = memberId;
            }

            if (memberType !== undefined) {
                localVarQueryParameter['member_type'] = memberType;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = (updatedAt as any instanceof Date) ?
                    (updatedAt as any).toISOString() :
                    updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a specific dropbox membership.
         * @summary Get Information on a Specific Dropbox Membership
         * @param {string} id 
         * @param {string} [embed5B5D] embed%5B%5D&#x3D;member (member object from member_id), embed%5B%5D&#x3D;dropbox (dropbox object from dropbox_id)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInformationonaSpecificDropboxMembership: async (id: string, embed5B5D?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getInformationonaSpecificDropboxMembership', 'id', id)
            const localVarPath = `/dropbox_memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (embed5B5D !== undefined) {
                localVarQueryParameter['embed%5B%5D'] = embed5B5D;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a direct dropbox membership. Note: If the user also has indirect membership through a group, the user will still have access to the dropbox.
         * @summary Remove a Member from a Dropbox
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeaMemberfromaDropbox: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeaMemberfromaDropbox', 'id', id)
            const localVarPath = `/dropbox_memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing dropbox membership.
         * @summary Update a Dropbox Membership
         * @param {string} id 
         * @param {DropboxMembershipsUpdateParams} dropboxMembershipsUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateaDropboxMembership: async (id: string, dropboxMembershipsUpdateParams: DropboxMembershipsUpdateParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateaDropboxMembership', 'id', id)
            // verify required parameter 'dropboxMembershipsUpdateParams' is not null or undefined
            assertParamExists('updateaDropboxMembership', 'dropboxMembershipsUpdateParams', dropboxMembershipsUpdateParams)
            const localVarPath = `/dropbox_memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dropboxMembershipsUpdateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DropboxMembershipsApi - functional programming interface
 * @export
 */
export const DropboxMembershipsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DropboxMembershipsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a user or group as a member of this dropbox.
         * @summary Add a Dropbox Member
         * @param {DropboxMembershipsParams} dropboxMembershipsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addaDropboxMember(dropboxMembershipsParams: DropboxMembershipsParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DropboxMembershipsParams>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addaDropboxMember(dropboxMembershipsParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a listing of information about the current members of a given dropbox.
         * @summary get_dropbox_memberships
         * @param {boolean} [canInviteSubmitters] 
         * @param {boolean} [canReceivePackages] 
         * @param {boolean} [canSubmitPackages] 
         * @param {string} [createdAt] 
         * @param {string} [creatorId] 
         * @param {boolean} [deactivated] Filters memberships with member_type &#x3D; \&quot;user\&quot; by their \&quot;deactivated\&quot; attribute.
         * @param {string} [dropboxId] 
         * @param {string} [embed5B5D] embed%5B%5D&#x3D;member (user or group object from member_id), embed%5B%5D&#x3D;dropbox (dropbox object from dropbox_id)
         * @param {boolean} [inherited] Specifies whether or not to include inherited memberships in the response. Typically used when an admin is looking at the memberships for a particular member_id or when a user is looking at their own memberships.
         * @param {boolean} [manager] 
         * @param {string} [memberEmail] 
         * @param {string} [memberLastLoginAt] 
         * @param {string} [memberLastName] 
         * @param {boolean} [memberSystemGroup] 
         * @param {string} [memberId] 
         * @param {string} [memberType] Either \&quot;user\&quot; or \&quot;group\&quot;
         * @param {string} [q] Search member.email, member.first_name, member.last_name, and member.name.
         * @param {string} [updatedAt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDropboxMemberships(canInviteSubmitters?: boolean, canReceivePackages?: boolean, canSubmitPackages?: boolean, createdAt?: string, creatorId?: string, deactivated?: boolean, dropboxId?: string, embed5B5D?: string, inherited?: boolean, manager?: boolean, memberEmail?: string, memberLastLoginAt?: string, memberLastName?: string, memberSystemGroup?: boolean, memberId?: string, memberType?: string, q?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DropboxMembershipsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDropboxMemberships(canInviteSubmitters, canReceivePackages, canSubmitPackages, createdAt, creatorId, deactivated, dropboxId, embed5B5D, inherited, manager, memberEmail, memberLastLoginAt, memberLastName, memberSystemGroup, memberId, memberType, q, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information on a specific dropbox membership.
         * @summary Get Information on a Specific Dropbox Membership
         * @param {string} id 
         * @param {string} [embed5B5D] embed%5B%5D&#x3D;member (member object from member_id), embed%5B%5D&#x3D;dropbox (dropbox object from dropbox_id)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInformationonaSpecificDropboxMembership(id: string, embed5B5D?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DropboxMembershipsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInformationonaSpecificDropboxMembership(id, embed5B5D, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a direct dropbox membership. Note: If the user also has indirect membership through a group, the user will still have access to the dropbox.
         * @summary Remove a Member from a Dropbox
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeaMemberfromaDropbox(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeaMemberfromaDropbox(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing dropbox membership.
         * @summary Update a Dropbox Membership
         * @param {string} id 
         * @param {DropboxMembershipsUpdateParams} dropboxMembershipsUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateaDropboxMembership(id: string, dropboxMembershipsUpdateParams: DropboxMembershipsUpdateParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateaDropboxMembership(id, dropboxMembershipsUpdateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DropboxMembershipsApi - factory interface
 * @export
 */
export const DropboxMembershipsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DropboxMembershipsApiFp(configuration)
    return {
        /**
         * Add a user or group as a member of this dropbox.
         * @summary Add a Dropbox Member
         * @param {DropboxMembershipsParams} dropboxMembershipsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addaDropboxMember(dropboxMembershipsParams: DropboxMembershipsParams, options?: any): AxiosPromise<DropboxMembershipsParams> {
            return localVarFp.addaDropboxMember(dropboxMembershipsParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a listing of information about the current members of a given dropbox.
         * @summary get_dropbox_memberships
         * @param {boolean} [canInviteSubmitters] 
         * @param {boolean} [canReceivePackages] 
         * @param {boolean} [canSubmitPackages] 
         * @param {string} [createdAt] 
         * @param {string} [creatorId] 
         * @param {boolean} [deactivated] Filters memberships with member_type &#x3D; \&quot;user\&quot; by their \&quot;deactivated\&quot; attribute.
         * @param {string} [dropboxId] 
         * @param {string} [embed5B5D] embed%5B%5D&#x3D;member (user or group object from member_id), embed%5B%5D&#x3D;dropbox (dropbox object from dropbox_id)
         * @param {boolean} [inherited] Specifies whether or not to include inherited memberships in the response. Typically used when an admin is looking at the memberships for a particular member_id or when a user is looking at their own memberships.
         * @param {boolean} [manager] 
         * @param {string} [memberEmail] 
         * @param {string} [memberLastLoginAt] 
         * @param {string} [memberLastName] 
         * @param {boolean} [memberSystemGroup] 
         * @param {string} [memberId] 
         * @param {string} [memberType] Either \&quot;user\&quot; or \&quot;group\&quot;
         * @param {string} [q] Search member.email, member.first_name, member.last_name, and member.name.
         * @param {string} [updatedAt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDropboxMemberships(canInviteSubmitters?: boolean, canReceivePackages?: boolean, canSubmitPackages?: boolean, createdAt?: string, creatorId?: string, deactivated?: boolean, dropboxId?: string, embed5B5D?: string, inherited?: boolean, manager?: boolean, memberEmail?: string, memberLastLoginAt?: string, memberLastName?: string, memberSystemGroup?: boolean, memberId?: string, memberType?: string, q?: string, updatedAt?: string, options?: any): AxiosPromise<Array<DropboxMembershipsResponse>> {
            return localVarFp.getDropboxMemberships(canInviteSubmitters, canReceivePackages, canSubmitPackages, createdAt, creatorId, deactivated, dropboxId, embed5B5D, inherited, manager, memberEmail, memberLastLoginAt, memberLastName, memberSystemGroup, memberId, memberType, q, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on a specific dropbox membership.
         * @summary Get Information on a Specific Dropbox Membership
         * @param {string} id 
         * @param {string} [embed5B5D] embed%5B%5D&#x3D;member (member object from member_id), embed%5B%5D&#x3D;dropbox (dropbox object from dropbox_id)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInformationonaSpecificDropboxMembership(id: string, embed5B5D?: string, options?: any): AxiosPromise<DropboxMembershipsResponse> {
            return localVarFp.getInformationonaSpecificDropboxMembership(id, embed5B5D, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a direct dropbox membership. Note: If the user also has indirect membership through a group, the user will still have access to the dropbox.
         * @summary Remove a Member from a Dropbox
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeaMemberfromaDropbox(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeaMemberfromaDropbox(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing dropbox membership.
         * @summary Update a Dropbox Membership
         * @param {string} id 
         * @param {DropboxMembershipsUpdateParams} dropboxMembershipsUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateaDropboxMembership(id: string, dropboxMembershipsUpdateParams: DropboxMembershipsUpdateParams, options?: any): AxiosPromise<void> {
            return localVarFp.updateaDropboxMembership(id, dropboxMembershipsUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addaDropboxMember operation in DropboxMembershipsApi.
 * @export
 * @interface DropboxMembershipsApiAddaDropboxMemberRequest
 */
export interface DropboxMembershipsApiAddaDropboxMemberRequest {
    /**
     * 
     * @type {DropboxMembershipsParams}
     * @memberof DropboxMembershipsApiAddaDropboxMember
     */
    readonly dropboxMembershipsParams: DropboxMembershipsParams
}

/**
 * Request parameters for getDropboxMemberships operation in DropboxMembershipsApi.
 * @export
 * @interface DropboxMembershipsApiGetDropboxMembershipsRequest
 */
export interface DropboxMembershipsApiGetDropboxMembershipsRequest {
    /**
     * 
     * @type {boolean}
     * @memberof DropboxMembershipsApiGetDropboxMemberships
     */
    readonly canInviteSubmitters?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DropboxMembershipsApiGetDropboxMemberships
     */
    readonly canReceivePackages?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DropboxMembershipsApiGetDropboxMemberships
     */
    readonly canSubmitPackages?: boolean

    /**
     * 
     * @type {string}
     * @memberof DropboxMembershipsApiGetDropboxMemberships
     */
    readonly createdAt?: string

    /**
     * 
     * @type {string}
     * @memberof DropboxMembershipsApiGetDropboxMemberships
     */
    readonly creatorId?: string

    /**
     * Filters memberships with member_type &#x3D; \&quot;user\&quot; by their \&quot;deactivated\&quot; attribute.
     * @type {boolean}
     * @memberof DropboxMembershipsApiGetDropboxMemberships
     */
    readonly deactivated?: boolean

    /**
     * 
     * @type {string}
     * @memberof DropboxMembershipsApiGetDropboxMemberships
     */
    readonly dropboxId?: string

    /**
     * embed%5B%5D&#x3D;member (user or group object from member_id), embed%5B%5D&#x3D;dropbox (dropbox object from dropbox_id)
     * @type {string}
     * @memberof DropboxMembershipsApiGetDropboxMemberships
     */
    readonly embed5B5D?: string

    /**
     * Specifies whether or not to include inherited memberships in the response. Typically used when an admin is looking at the memberships for a particular member_id or when a user is looking at their own memberships.
     * @type {boolean}
     * @memberof DropboxMembershipsApiGetDropboxMemberships
     */
    readonly inherited?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DropboxMembershipsApiGetDropboxMemberships
     */
    readonly manager?: boolean

    /**
     * 
     * @type {string}
     * @memberof DropboxMembershipsApiGetDropboxMemberships
     */
    readonly memberEmail?: string

    /**
     * 
     * @type {string}
     * @memberof DropboxMembershipsApiGetDropboxMemberships
     */
    readonly memberLastLoginAt?: string

    /**
     * 
     * @type {string}
     * @memberof DropboxMembershipsApiGetDropboxMemberships
     */
    readonly memberLastName?: string

    /**
     * 
     * @type {boolean}
     * @memberof DropboxMembershipsApiGetDropboxMemberships
     */
    readonly memberSystemGroup?: boolean

    /**
     * 
     * @type {string}
     * @memberof DropboxMembershipsApiGetDropboxMemberships
     */
    readonly memberId?: string

    /**
     * Either \&quot;user\&quot; or \&quot;group\&quot;
     * @type {string}
     * @memberof DropboxMembershipsApiGetDropboxMemberships
     */
    readonly memberType?: string

    /**
     * Search member.email, member.first_name, member.last_name, and member.name.
     * @type {string}
     * @memberof DropboxMembershipsApiGetDropboxMemberships
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DropboxMembershipsApiGetDropboxMemberships
     */
    readonly updatedAt?: string
}

/**
 * Request parameters for getInformationonaSpecificDropboxMembership operation in DropboxMembershipsApi.
 * @export
 * @interface DropboxMembershipsApiGetInformationonaSpecificDropboxMembershipRequest
 */
export interface DropboxMembershipsApiGetInformationonaSpecificDropboxMembershipRequest {
    /**
     * 
     * @type {string}
     * @memberof DropboxMembershipsApiGetInformationonaSpecificDropboxMembership
     */
    readonly id: string

    /**
     * embed%5B%5D&#x3D;member (member object from member_id), embed%5B%5D&#x3D;dropbox (dropbox object from dropbox_id)
     * @type {string}
     * @memberof DropboxMembershipsApiGetInformationonaSpecificDropboxMembership
     */
    readonly embed5B5D?: string
}

/**
 * Request parameters for removeaMemberfromaDropbox operation in DropboxMembershipsApi.
 * @export
 * @interface DropboxMembershipsApiRemoveaMemberfromaDropboxRequest
 */
export interface DropboxMembershipsApiRemoveaMemberfromaDropboxRequest {
    /**
     * 
     * @type {string}
     * @memberof DropboxMembershipsApiRemoveaMemberfromaDropbox
     */
    readonly id: string
}

/**
 * Request parameters for updateaDropboxMembership operation in DropboxMembershipsApi.
 * @export
 * @interface DropboxMembershipsApiUpdateaDropboxMembershipRequest
 */
export interface DropboxMembershipsApiUpdateaDropboxMembershipRequest {
    /**
     * 
     * @type {string}
     * @memberof DropboxMembershipsApiUpdateaDropboxMembership
     */
    readonly id: string

    /**
     * 
     * @type {DropboxMembershipsUpdateParams}
     * @memberof DropboxMembershipsApiUpdateaDropboxMembership
     */
    readonly dropboxMembershipsUpdateParams: DropboxMembershipsUpdateParams
}

/**
 * DropboxMembershipsApi - object-oriented interface
 * @export
 * @class DropboxMembershipsApi
 * @extends {BaseAPI}
 */
export class DropboxMembershipsApi extends BaseAPI {
    /**
     * Add a user or group as a member of this dropbox.
     * @summary Add a Dropbox Member
     * @param {DropboxMembershipsApiAddaDropboxMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DropboxMembershipsApi
     */
    public addaDropboxMember(requestParameters: DropboxMembershipsApiAddaDropboxMemberRequest, options?: any) {
        return DropboxMembershipsApiFp(this.configuration).addaDropboxMember(requestParameters.dropboxMembershipsParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a listing of information about the current members of a given dropbox.
     * @summary get_dropbox_memberships
     * @param {DropboxMembershipsApiGetDropboxMembershipsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DropboxMembershipsApi
     */
    public getDropboxMemberships(requestParameters: DropboxMembershipsApiGetDropboxMembershipsRequest = {}, options?: any) {
        return DropboxMembershipsApiFp(this.configuration).getDropboxMemberships(requestParameters.canInviteSubmitters, requestParameters.canReceivePackages, requestParameters.canSubmitPackages, requestParameters.createdAt, requestParameters.creatorId, requestParameters.deactivated, requestParameters.dropboxId, requestParameters.embed5B5D, requestParameters.inherited, requestParameters.manager, requestParameters.memberEmail, requestParameters.memberLastLoginAt, requestParameters.memberLastName, requestParameters.memberSystemGroup, requestParameters.memberId, requestParameters.memberType, requestParameters.q, requestParameters.updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on a specific dropbox membership.
     * @summary Get Information on a Specific Dropbox Membership
     * @param {DropboxMembershipsApiGetInformationonaSpecificDropboxMembershipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DropboxMembershipsApi
     */
    public getInformationonaSpecificDropboxMembership(requestParameters: DropboxMembershipsApiGetInformationonaSpecificDropboxMembershipRequest, options?: any) {
        return DropboxMembershipsApiFp(this.configuration).getInformationonaSpecificDropboxMembership(requestParameters.id, requestParameters.embed5B5D, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a direct dropbox membership. Note: If the user also has indirect membership through a group, the user will still have access to the dropbox.
     * @summary Remove a Member from a Dropbox
     * @param {DropboxMembershipsApiRemoveaMemberfromaDropboxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DropboxMembershipsApi
     */
    public removeaMemberfromaDropbox(requestParameters: DropboxMembershipsApiRemoveaMemberfromaDropboxRequest, options?: any) {
        return DropboxMembershipsApiFp(this.configuration).removeaMemberfromaDropbox(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing dropbox membership.
     * @summary Update a Dropbox Membership
     * @param {DropboxMembershipsApiUpdateaDropboxMembershipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DropboxMembershipsApi
     */
    public updateaDropboxMembership(requestParameters: DropboxMembershipsApiUpdateaDropboxMembershipRequest, options?: any) {
        return DropboxMembershipsApiFp(this.configuration).updateaDropboxMembership(requestParameters.id, requestParameters.dropboxMembershipsUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DropboxesApi - axios parameter creator
 * @export
 */
export const DropboxesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new shared inbox.
         * @summary Create a New Shared Inbox
         * @param {DropboxesParams} dropboxesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createaNewSharedInbox: async (dropboxesParams: DropboxesParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dropboxesParams' is not null or undefined
            assertParamExists('createaNewSharedInbox', 'dropboxesParams', dropboxesParams)
            const localVarPath = `/dropboxes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dropboxesParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific shared inbox, specified by shared inbox ID.
         * @summary Delete a Specific Shared Inbox
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteaSpecificSharedInbox: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteaSpecificSharedInbox', 'id', id)
            const localVarPath = `/dropboxes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information on a specific shared inbox.
         * @summary Get Information on a Specific Shared Inbox
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInformationonaSpecificSharedInbox: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getInformationonaSpecificSharedInbox', 'id', id)
            const localVarPath = `/dropboxes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a listing of all shared inboxes.
         * @summary Get a Listing of All Shared Inboxes
         * @param {string} [createdAt] Time at which the shared inbox was created.
         * @param {string} [name] 
         * @param {string} [updatedAt] Time at which the shared inbox was last updated.
         * @param {string} [q] Searches across shared inbox descriptions and names.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getaListingofAllSharedInboxes: async (createdAt?: string, name?: string, updatedAt?: string, q?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dropboxes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = (createdAt as any instanceof Date) ?
                    (createdAt as any).toISOString() :
                    createdAt;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = (updatedAt as any instanceof Date) ?
                    (updatedAt as any).toISOString() :
                    updatedAt;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make changes to an existing shared inbox.
         * @summary Update a Shared Inbox
         * @param {string} id 
         * @param {DropboxesParams} dropboxesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateaSharedInbox: async (id: string, dropboxesParams: DropboxesParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateaSharedInbox', 'id', id)
            // verify required parameter 'dropboxesParams' is not null or undefined
            assertParamExists('updateaSharedInbox', 'dropboxesParams', dropboxesParams)
            const localVarPath = `/dropboxes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dropboxesParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DropboxesApi - functional programming interface
 * @export
 */
export const DropboxesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DropboxesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new shared inbox.
         * @summary Create a New Shared Inbox
         * @param {DropboxesParams} dropboxesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createaNewSharedInbox(dropboxesParams: DropboxesParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DropboxesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createaNewSharedInbox(dropboxesParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a specific shared inbox, specified by shared inbox ID.
         * @summary Delete a Specific Shared Inbox
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteaSpecificSharedInbox(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteaSpecificSharedInbox(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information on a specific shared inbox.
         * @summary Get Information on a Specific Shared Inbox
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInformationonaSpecificSharedInbox(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DropboxesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInformationonaSpecificSharedInbox(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a listing of all shared inboxes.
         * @summary Get a Listing of All Shared Inboxes
         * @param {string} [createdAt] Time at which the shared inbox was created.
         * @param {string} [name] 
         * @param {string} [updatedAt] Time at which the shared inbox was last updated.
         * @param {string} [q] Searches across shared inbox descriptions and names.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getaListingofAllSharedInboxes(createdAt?: string, name?: string, updatedAt?: string, q?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DropboxesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getaListingofAllSharedInboxes(createdAt, name, updatedAt, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Make changes to an existing shared inbox.
         * @summary Update a Shared Inbox
         * @param {string} id 
         * @param {DropboxesParams} dropboxesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateaSharedInbox(id: string, dropboxesParams: DropboxesParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateaSharedInbox(id, dropboxesParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DropboxesApi - factory interface
 * @export
 */
export const DropboxesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DropboxesApiFp(configuration)
    return {
        /**
         * Create a new shared inbox.
         * @summary Create a New Shared Inbox
         * @param {DropboxesParams} dropboxesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createaNewSharedInbox(dropboxesParams: DropboxesParams, options?: any): AxiosPromise<DropboxesResponse> {
            return localVarFp.createaNewSharedInbox(dropboxesParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific shared inbox, specified by shared inbox ID.
         * @summary Delete a Specific Shared Inbox
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteaSpecificSharedInbox(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteaSpecificSharedInbox(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information on a specific shared inbox.
         * @summary Get Information on a Specific Shared Inbox
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInformationonaSpecificSharedInbox(id: string, options?: any): AxiosPromise<DropboxesResponse> {
            return localVarFp.getInformationonaSpecificSharedInbox(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a listing of all shared inboxes.
         * @summary Get a Listing of All Shared Inboxes
         * @param {string} [createdAt] Time at which the shared inbox was created.
         * @param {string} [name] 
         * @param {string} [updatedAt] Time at which the shared inbox was last updated.
         * @param {string} [q] Searches across shared inbox descriptions and names.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getaListingofAllSharedInboxes(createdAt?: string, name?: string, updatedAt?: string, q?: string, options?: any): AxiosPromise<Array<DropboxesResponse>> {
            return localVarFp.getaListingofAllSharedInboxes(createdAt, name, updatedAt, q, options).then((request) => request(axios, basePath));
        },
        /**
         * Make changes to an existing shared inbox.
         * @summary Update a Shared Inbox
         * @param {string} id 
         * @param {DropboxesParams} dropboxesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateaSharedInbox(id: string, dropboxesParams: DropboxesParams, options?: any): AxiosPromise<void> {
            return localVarFp.updateaSharedInbox(id, dropboxesParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createaNewSharedInbox operation in DropboxesApi.
 * @export
 * @interface DropboxesApiCreateaNewSharedInboxRequest
 */
export interface DropboxesApiCreateaNewSharedInboxRequest {
    /**
     * 
     * @type {DropboxesParams}
     * @memberof DropboxesApiCreateaNewSharedInbox
     */
    readonly dropboxesParams: DropboxesParams
}

/**
 * Request parameters for deleteaSpecificSharedInbox operation in DropboxesApi.
 * @export
 * @interface DropboxesApiDeleteaSpecificSharedInboxRequest
 */
export interface DropboxesApiDeleteaSpecificSharedInboxRequest {
    /**
     * 
     * @type {string}
     * @memberof DropboxesApiDeleteaSpecificSharedInbox
     */
    readonly id: string
}

/**
 * Request parameters for getInformationonaSpecificSharedInbox operation in DropboxesApi.
 * @export
 * @interface DropboxesApiGetInformationonaSpecificSharedInboxRequest
 */
export interface DropboxesApiGetInformationonaSpecificSharedInboxRequest {
    /**
     * 
     * @type {string}
     * @memberof DropboxesApiGetInformationonaSpecificSharedInbox
     */
    readonly id: string
}

/**
 * Request parameters for getaListingofAllSharedInboxes operation in DropboxesApi.
 * @export
 * @interface DropboxesApiGetaListingofAllSharedInboxesRequest
 */
export interface DropboxesApiGetaListingofAllSharedInboxesRequest {
    /**
     * Time at which the shared inbox was created.
     * @type {string}
     * @memberof DropboxesApiGetaListingofAllSharedInboxes
     */
    readonly createdAt?: string

    /**
     * 
     * @type {string}
     * @memberof DropboxesApiGetaListingofAllSharedInboxes
     */
    readonly name?: string

    /**
     * Time at which the shared inbox was last updated.
     * @type {string}
     * @memberof DropboxesApiGetaListingofAllSharedInboxes
     */
    readonly updatedAt?: string

    /**
     * Searches across shared inbox descriptions and names.
     * @type {string}
     * @memberof DropboxesApiGetaListingofAllSharedInboxes
     */
    readonly q?: string
}

/**
 * Request parameters for updateaSharedInbox operation in DropboxesApi.
 * @export
 * @interface DropboxesApiUpdateaSharedInboxRequest
 */
export interface DropboxesApiUpdateaSharedInboxRequest {
    /**
     * 
     * @type {string}
     * @memberof DropboxesApiUpdateaSharedInbox
     */
    readonly id: string

    /**
     * 
     * @type {DropboxesParams}
     * @memberof DropboxesApiUpdateaSharedInbox
     */
    readonly dropboxesParams: DropboxesParams
}

/**
 * DropboxesApi - object-oriented interface
 * @export
 * @class DropboxesApi
 * @extends {BaseAPI}
 */
export class DropboxesApi extends BaseAPI {
    /**
     * Create a new shared inbox.
     * @summary Create a New Shared Inbox
     * @param {DropboxesApiCreateaNewSharedInboxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DropboxesApi
     */
    public createaNewSharedInbox(requestParameters: DropboxesApiCreateaNewSharedInboxRequest, options?: any) {
        return DropboxesApiFp(this.configuration).createaNewSharedInbox(requestParameters.dropboxesParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific shared inbox, specified by shared inbox ID.
     * @summary Delete a Specific Shared Inbox
     * @param {DropboxesApiDeleteaSpecificSharedInboxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DropboxesApi
     */
    public deleteaSpecificSharedInbox(requestParameters: DropboxesApiDeleteaSpecificSharedInboxRequest, options?: any) {
        return DropboxesApiFp(this.configuration).deleteaSpecificSharedInbox(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information on a specific shared inbox.
     * @summary Get Information on a Specific Shared Inbox
     * @param {DropboxesApiGetInformationonaSpecificSharedInboxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DropboxesApi
     */
    public getInformationonaSpecificSharedInbox(requestParameters: DropboxesApiGetInformationonaSpecificSharedInboxRequest, options?: any) {
        return DropboxesApiFp(this.configuration).getInformationonaSpecificSharedInbox(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a listing of all shared inboxes.
     * @summary Get a Listing of All Shared Inboxes
     * @param {DropboxesApiGetaListingofAllSharedInboxesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DropboxesApi
     */
    public getaListingofAllSharedInboxes(requestParameters: DropboxesApiGetaListingofAllSharedInboxesRequest = {}, options?: any) {
        return DropboxesApiFp(this.configuration).getaListingofAllSharedInboxes(requestParameters.createdAt, requestParameters.name, requestParameters.updatedAt, requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Make changes to an existing shared inbox.
     * @summary Update a Shared Inbox
     * @param {DropboxesApiUpdateaSharedInboxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DropboxesApi
     */
    public updateaSharedInbox(requestParameters: DropboxesApiUpdateaSharedInboxRequest, options?: any) {
        return DropboxesApiFp(this.configuration).updateaSharedInbox(requestParameters.id, requestParameters.dropboxesParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IntegrationsKmsProfilesApi - axios parameter creator
 * @export
 */
export const IntegrationsKmsProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new KMS profile. Returns the created KMS profile, without the API key. Requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
         * @summary Create a new key-management service (KMS) profile
         * @param {KmsProfileRequest} kmsProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createanewkeyManagementserviceKMSprofile: async (kmsProfileRequest: KmsProfileRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'kmsProfileRequest' is not null or undefined
            assertParamExists('createanewkeyManagementserviceKMSprofile', 'kmsProfileRequest', kmsProfileRequest)
            const localVarPath = `/integrations/kms_profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(kmsProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the deleted KMS profile for the specified kms_profile_id, without the API key. Requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
         * @summary Delete the key-management service (KMS) profile
         * @param {string} kmsProfileId Key management service profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletethekeyManagementserviceKMSprofile: async (kmsProfileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'kmsProfileId' is not null or undefined
            assertParamExists('deletethekeyManagementserviceKMSprofile', 'kmsProfileId', kmsProfileId)
            const localVarPath = `/integrations/kms_profiles/{kms_profile_id}`
                .replace(`{${"kms_profile_id"}}`, encodeURIComponent(String(kmsProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all KMS profiles, without the API key. Requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
         * @summary Get a list of all key-management service (KMS) profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getalistofallkeyManagementserviceKMSprofiles: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrations/kms_profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of nodes associated with the specified KMS profile. This method requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
         * @summary Get a list of nodes associated with the specified key-management service (KMS) profile
         * @param {string} kmsProfileId The key management service profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getalistofnodesassociatedwiththespecifiedkeyManagementserviceKMSprofile: async (kmsProfileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'kmsProfileId' is not null or undefined
            assertParamExists('getalistofnodesassociatedwiththespecifiedkeyManagementserviceKMSprofile', 'kmsProfileId', kmsProfileId)
            const localVarPath = `/integrations/kms_profiles/{kms_profile_id}/nodes`
                .replace(`{${"kms_profile_id"}}`, encodeURIComponent(String(kmsProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the created KMS profile for the specified kms_profile_id, without the API key. Requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
         * @summary Get the key-management service (KMS) profile
         * @param {string} kmsProfileId Key management service profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getthekeyManagementserviceKMSprofile: async (kmsProfileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'kmsProfileId' is not null or undefined
            assertParamExists('getthekeyManagementserviceKMSprofile', 'kmsProfileId', kmsProfileId)
            const localVarPath = `/integrations/kms_profiles/{kms_profile_id}`
                .replace(`{${"kms_profile_id"}}`, encodeURIComponent(String(kmsProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the updated KMS profile, without the API key. Requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
         * @summary Update the key-management service (KMS) profile
         * @param {string} kmsProfileId Key management service (KMS) profile ID
         * @param {IntegrationsKmsProfilesRequest} [integrationsKmsProfilesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatethekeyManagementserviceKMSprofile: async (kmsProfileId: string, integrationsKmsProfilesRequest?: IntegrationsKmsProfilesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'kmsProfileId' is not null or undefined
            assertParamExists('updatethekeyManagementserviceKMSprofile', 'kmsProfileId', kmsProfileId)
            const localVarPath = `/integrations/kms_profiles/{kms_profile_id}`
                .replace(`{${"kms_profile_id"}}`, encodeURIComponent(String(kmsProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(integrationsKmsProfilesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationsKmsProfilesApi - functional programming interface
 * @export
 */
export const IntegrationsKmsProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntegrationsKmsProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new KMS profile. Returns the created KMS profile, without the API key. Requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
         * @summary Create a new key-management service (KMS) profile
         * @param {KmsProfileRequest} kmsProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createanewkeyManagementserviceKMSprofile(kmsProfileRequest: KmsProfileRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KmsProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createanewkeyManagementserviceKMSprofile(kmsProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the deleted KMS profile for the specified kms_profile_id, without the API key. Requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
         * @summary Delete the key-management service (KMS) profile
         * @param {string} kmsProfileId Key management service profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletethekeyManagementserviceKMSprofile(kmsProfileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KmsProfileResponseDelete>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletethekeyManagementserviceKMSprofile(kmsProfileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all KMS profiles, without the API key. Requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
         * @summary Get a list of all key-management service (KMS) profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getalistofallkeyManagementserviceKMSprofiles(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KmsProfileResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getalistofallkeyManagementserviceKMSprofiles(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of nodes associated with the specified KMS profile. This method requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
         * @summary Get a list of nodes associated with the specified key-management service (KMS) profile
         * @param {string} kmsProfileId The key management service profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getalistofnodesassociatedwiththespecifiedkeyManagementserviceKMSprofile(kmsProfileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KmsAocNode1>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getalistofnodesassociatedwiththespecifiedkeyManagementserviceKMSprofile(kmsProfileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the created KMS profile for the specified kms_profile_id, without the API key. Requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
         * @summary Get the key-management service (KMS) profile
         * @param {string} kmsProfileId Key management service profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getthekeyManagementserviceKMSprofile(kmsProfileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KmsProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getthekeyManagementserviceKMSprofile(kmsProfileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the updated KMS profile, without the API key. Requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
         * @summary Update the key-management service (KMS) profile
         * @param {string} kmsProfileId Key management service (KMS) profile ID
         * @param {IntegrationsKmsProfilesRequest} [integrationsKmsProfilesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatethekeyManagementserviceKMSprofile(kmsProfileId: string, integrationsKmsProfilesRequest?: IntegrationsKmsProfilesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatethekeyManagementserviceKMSprofile(kmsProfileId, integrationsKmsProfilesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IntegrationsKmsProfilesApi - factory interface
 * @export
 */
export const IntegrationsKmsProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntegrationsKmsProfilesApiFp(configuration)
    return {
        /**
         * Creates a new KMS profile. Returns the created KMS profile, without the API key. Requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
         * @summary Create a new key-management service (KMS) profile
         * @param {KmsProfileRequest} kmsProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createanewkeyManagementserviceKMSprofile(kmsProfileRequest: KmsProfileRequest, options?: any): AxiosPromise<KmsProfileResponse> {
            return localVarFp.createanewkeyManagementserviceKMSprofile(kmsProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the deleted KMS profile for the specified kms_profile_id, without the API key. Requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
         * @summary Delete the key-management service (KMS) profile
         * @param {string} kmsProfileId Key management service profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletethekeyManagementserviceKMSprofile(kmsProfileId: string, options?: any): AxiosPromise<KmsProfileResponseDelete> {
            return localVarFp.deletethekeyManagementserviceKMSprofile(kmsProfileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all KMS profiles, without the API key. Requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
         * @summary Get a list of all key-management service (KMS) profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getalistofallkeyManagementserviceKMSprofiles(options?: any): AxiosPromise<Array<KmsProfileResponse>> {
            return localVarFp.getalistofallkeyManagementserviceKMSprofiles(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of nodes associated with the specified KMS profile. This method requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
         * @summary Get a list of nodes associated with the specified key-management service (KMS) profile
         * @param {string} kmsProfileId The key management service profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getalistofnodesassociatedwiththespecifiedkeyManagementserviceKMSprofile(kmsProfileId: string, options?: any): AxiosPromise<Array<KmsAocNode1>> {
            return localVarFp.getalistofnodesassociatedwiththespecifiedkeyManagementserviceKMSprofile(kmsProfileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the created KMS profile for the specified kms_profile_id, without the API key. Requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
         * @summary Get the key-management service (KMS) profile
         * @param {string} kmsProfileId Key management service profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getthekeyManagementserviceKMSprofile(kmsProfileId: string, options?: any): AxiosPromise<KmsProfileResponse> {
            return localVarFp.getthekeyManagementserviceKMSprofile(kmsProfileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the updated KMS profile, without the API key. Requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
         * @summary Update the key-management service (KMS) profile
         * @param {string} kmsProfileId Key management service (KMS) profile ID
         * @param {IntegrationsKmsProfilesRequest} [integrationsKmsProfilesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatethekeyManagementserviceKMSprofile(kmsProfileId: string, integrationsKmsProfilesRequest?: IntegrationsKmsProfilesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updatethekeyManagementserviceKMSprofile(kmsProfileId, integrationsKmsProfilesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createanewkeyManagementserviceKMSprofile operation in IntegrationsKmsProfilesApi.
 * @export
 * @interface IntegrationsKmsProfilesApiCreateanewkeyManagementserviceKMSprofileRequest
 */
export interface IntegrationsKmsProfilesApiCreateanewkeyManagementserviceKMSprofileRequest {
    /**
     * 
     * @type {KmsProfileRequest}
     * @memberof IntegrationsKmsProfilesApiCreateanewkeyManagementserviceKMSprofile
     */
    readonly kmsProfileRequest: KmsProfileRequest
}

/**
 * Request parameters for deletethekeyManagementserviceKMSprofile operation in IntegrationsKmsProfilesApi.
 * @export
 * @interface IntegrationsKmsProfilesApiDeletethekeyManagementserviceKMSprofileRequest
 */
export interface IntegrationsKmsProfilesApiDeletethekeyManagementserviceKMSprofileRequest {
    /**
     * Key management service profile ID
     * @type {string}
     * @memberof IntegrationsKmsProfilesApiDeletethekeyManagementserviceKMSprofile
     */
    readonly kmsProfileId: string
}

/**
 * Request parameters for getalistofnodesassociatedwiththespecifiedkeyManagementserviceKMSprofile operation in IntegrationsKmsProfilesApi.
 * @export
 * @interface IntegrationsKmsProfilesApiGetalistofnodesassociatedwiththespecifiedkeyManagementserviceKMSprofileRequest
 */
export interface IntegrationsKmsProfilesApiGetalistofnodesassociatedwiththespecifiedkeyManagementserviceKMSprofileRequest {
    /**
     * The key management service profile ID
     * @type {string}
     * @memberof IntegrationsKmsProfilesApiGetalistofnodesassociatedwiththespecifiedkeyManagementserviceKMSprofile
     */
    readonly kmsProfileId: string
}

/**
 * Request parameters for getthekeyManagementserviceKMSprofile operation in IntegrationsKmsProfilesApi.
 * @export
 * @interface IntegrationsKmsProfilesApiGetthekeyManagementserviceKMSprofileRequest
 */
export interface IntegrationsKmsProfilesApiGetthekeyManagementserviceKMSprofileRequest {
    /**
     * Key management service profile ID
     * @type {string}
     * @memberof IntegrationsKmsProfilesApiGetthekeyManagementserviceKMSprofile
     */
    readonly kmsProfileId: string
}

/**
 * Request parameters for updatethekeyManagementserviceKMSprofile operation in IntegrationsKmsProfilesApi.
 * @export
 * @interface IntegrationsKmsProfilesApiUpdatethekeyManagementserviceKMSprofileRequest
 */
export interface IntegrationsKmsProfilesApiUpdatethekeyManagementserviceKMSprofileRequest {
    /**
     * Key management service (KMS) profile ID
     * @type {string}
     * @memberof IntegrationsKmsProfilesApiUpdatethekeyManagementserviceKMSprofile
     */
    readonly kmsProfileId: string

    /**
     * 
     * @type {IntegrationsKmsProfilesRequest}
     * @memberof IntegrationsKmsProfilesApiUpdatethekeyManagementserviceKMSprofile
     */
    readonly integrationsKmsProfilesRequest?: IntegrationsKmsProfilesRequest
}

/**
 * IntegrationsKmsProfilesApi - object-oriented interface
 * @export
 * @class IntegrationsKmsProfilesApi
 * @extends {BaseAPI}
 */
export class IntegrationsKmsProfilesApi extends BaseAPI {
    /**
     * Creates a new KMS profile. Returns the created KMS profile, without the API key. Requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
     * @summary Create a new key-management service (KMS) profile
     * @param {IntegrationsKmsProfilesApiCreateanewkeyManagementserviceKMSprofileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsKmsProfilesApi
     */
    public createanewkeyManagementserviceKMSprofile(requestParameters: IntegrationsKmsProfilesApiCreateanewkeyManagementserviceKMSprofileRequest, options?: any) {
        return IntegrationsKmsProfilesApiFp(this.configuration).createanewkeyManagementserviceKMSprofile(requestParameters.kmsProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the deleted KMS profile for the specified kms_profile_id, without the API key. Requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
     * @summary Delete the key-management service (KMS) profile
     * @param {IntegrationsKmsProfilesApiDeletethekeyManagementserviceKMSprofileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsKmsProfilesApi
     */
    public deletethekeyManagementserviceKMSprofile(requestParameters: IntegrationsKmsProfilesApiDeletethekeyManagementserviceKMSprofileRequest, options?: any) {
        return IntegrationsKmsProfilesApiFp(this.configuration).deletethekeyManagementserviceKMSprofile(requestParameters.kmsProfileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all KMS profiles, without the API key. Requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
     * @summary Get a list of all key-management service (KMS) profiles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsKmsProfilesApi
     */
    public getalistofallkeyManagementserviceKMSprofiles(options?: any) {
        return IntegrationsKmsProfilesApiFp(this.configuration).getalistofallkeyManagementserviceKMSprofiles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of nodes associated with the specified KMS profile. This method requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
     * @summary Get a list of nodes associated with the specified key-management service (KMS) profile
     * @param {IntegrationsKmsProfilesApiGetalistofnodesassociatedwiththespecifiedkeyManagementserviceKMSprofileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsKmsProfilesApi
     */
    public getalistofnodesassociatedwiththespecifiedkeyManagementserviceKMSprofile(requestParameters: IntegrationsKmsProfilesApiGetalistofnodesassociatedwiththespecifiedkeyManagementserviceKMSprofileRequest, options?: any) {
        return IntegrationsKmsProfilesApiFp(this.configuration).getalistofnodesassociatedwiththespecifiedkeyManagementserviceKMSprofile(requestParameters.kmsProfileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the created KMS profile for the specified kms_profile_id, without the API key. Requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
     * @summary Get the key-management service (KMS) profile
     * @param {IntegrationsKmsProfilesApiGetthekeyManagementserviceKMSprofileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsKmsProfilesApi
     */
    public getthekeyManagementserviceKMSprofile(requestParameters: IntegrationsKmsProfilesApiGetthekeyManagementserviceKMSprofileRequest, options?: any) {
        return IntegrationsKmsProfilesApiFp(this.configuration).getthekeyManagementserviceKMSprofile(requestParameters.kmsProfileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the updated KMS profile, without the API key. Requires admin privileges. For more information about the KMS profiles, see ibmaspera.com/help/admin/nodes/ssear_kms_managed_keys.
     * @summary Update the key-management service (KMS) profile
     * @param {IntegrationsKmsProfilesApiUpdatethekeyManagementserviceKMSprofileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsKmsProfilesApi
     */
    public updatethekeyManagementserviceKMSprofile(requestParameters: IntegrationsKmsProfilesApiUpdatethekeyManagementserviceKMSprofileRequest, options?: any) {
        return IntegrationsKmsProfilesApiFp(this.configuration).updatethekeyManagementserviceKMSprofile(requestParameters.kmsProfileId, requestParameters.integrationsKmsProfilesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IntegrationsWatermarkIdentitiesApi - axios parameter creator
 * @export
 */
export const IntegrationsWatermarkIdentitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns an array of identity objects in your AoC organization, which includes Irdeto identifying data as well as an embedded object with AoC user information. The admin can compare the Irdeto Identity ID to the corresponding AoC user. You can add an Irdeto identity ID to return a specific identity object. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
         * @summary Get an array of watermark identities
         * @param {number} identityId Irdeto identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getanarrayofwatermarkidentities: async (identityId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getanarrayofwatermarkidentities', 'identityId', identityId)
            const localVarPath = `/integrations/watermark/identities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identityId !== undefined) {
                localVarQueryParameter['identity_id'] = identityId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationsWatermarkIdentitiesApi - functional programming interface
 * @export
 */
export const IntegrationsWatermarkIdentitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntegrationsWatermarkIdentitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns an array of identity objects in your AoC organization, which includes Irdeto identifying data as well as an embedded object with AoC user information. The admin can compare the Irdeto Identity ID to the corresponding AoC user. You can add an Irdeto identity ID to return a specific identity object. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
         * @summary Get an array of watermark identities
         * @param {number} identityId Irdeto identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getanarrayofwatermarkidentities(identityId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationsWatermarkIdentitiesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getanarrayofwatermarkidentities(identityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IntegrationsWatermarkIdentitiesApi - factory interface
 * @export
 */
export const IntegrationsWatermarkIdentitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntegrationsWatermarkIdentitiesApiFp(configuration)
    return {
        /**
         * Returns an array of identity objects in your AoC organization, which includes Irdeto identifying data as well as an embedded object with AoC user information. The admin can compare the Irdeto Identity ID to the corresponding AoC user. You can add an Irdeto identity ID to return a specific identity object. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
         * @summary Get an array of watermark identities
         * @param {number} identityId Irdeto identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getanarrayofwatermarkidentities(identityId: number, options?: any): AxiosPromise<IntegrationsWatermarkIdentitiesResponse> {
            return localVarFp.getanarrayofwatermarkidentities(identityId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getanarrayofwatermarkidentities operation in IntegrationsWatermarkIdentitiesApi.
 * @export
 * @interface IntegrationsWatermarkIdentitiesApiGetanarrayofwatermarkidentitiesRequest
 */
export interface IntegrationsWatermarkIdentitiesApiGetanarrayofwatermarkidentitiesRequest {
    /**
     * Irdeto identity ID
     * @type {number}
     * @memberof IntegrationsWatermarkIdentitiesApiGetanarrayofwatermarkidentities
     */
    readonly identityId: number
}

/**
 * IntegrationsWatermarkIdentitiesApi - object-oriented interface
 * @export
 * @class IntegrationsWatermarkIdentitiesApi
 * @extends {BaseAPI}
 */
export class IntegrationsWatermarkIdentitiesApi extends BaseAPI {
    /**
     * Returns an array of identity objects in your AoC organization, which includes Irdeto identifying data as well as an embedded object with AoC user information. The admin can compare the Irdeto Identity ID to the corresponding AoC user. You can add an Irdeto identity ID to return a specific identity object. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
     * @summary Get an array of watermark identities
     * @param {IntegrationsWatermarkIdentitiesApiGetanarrayofwatermarkidentitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsWatermarkIdentitiesApi
     */
    public getanarrayofwatermarkidentities(requestParameters: IntegrationsWatermarkIdentitiesApiGetanarrayofwatermarkidentitiesRequest, options?: any) {
        return IntegrationsWatermarkIdentitiesApiFp(this.configuration).getanarrayofwatermarkidentities(requestParameters.identityId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IntegrationsWatermarkProfilesApi - axios parameter creator
 * @export
 */
export const IntegrationsWatermarkProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new watermarking profile. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
         * @summary Create a new watermarking profile
         * @param {WatermarkProfileCreateParams} watermarkProfileCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createanewwatermarkingprofile: async (watermarkProfileCreateParams: WatermarkProfileCreateParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'watermarkProfileCreateParams' is not null or undefined
            assertParamExists('createanewwatermarkingprofile', 'watermarkProfileCreateParams', watermarkProfileCreateParams)
            const localVarPath = `/integrations/watermark_profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(watermarkProfileCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific watermarking profile. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
         * @summary Delete a specific watermarking profile
         * @param {string} id Watermarking profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteaspecificwatermarkingprofile: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteaspecificwatermarkingprofile', 'id', id)
            const localVarPath = `/integrations/watermark_profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all watermarking profiles. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
         * @summary Get all watermarking profiles
         * @param {Include} [include] Includes the available nodes in the response object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getallwatermarkingprofiles: async (include?: Include, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrations/watermark_profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific watermarking profile. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
         * @summary Get a specific watermarking profile
         * @param {string} id Watermarking profile ID
         * @param {Include} [include] Includes the available nodes in the response object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getaspecificwatermarkingprofile: async (id: string, include?: Include, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getaspecificwatermarkingprofile', 'id', id)
            const localVarPath = `/integrations/watermark_profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a specific watermarking profile. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
         * @summary Update a specific watermarking profile
         * @param {string} id Watermarking profile ID
         * @param {WatermarkProfileUpdateParams} watermarkProfileUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateaspecificwatermarkingprofile: async (id: string, watermarkProfileUpdateParams: WatermarkProfileUpdateParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateaspecificwatermarkingprofile', 'id', id)
            // verify required parameter 'watermarkProfileUpdateParams' is not null or undefined
            assertParamExists('updateaspecificwatermarkingprofile', 'watermarkProfileUpdateParams', watermarkProfileUpdateParams)
            const localVarPath = `/integrations/watermark_profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(watermarkProfileUpdateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationsWatermarkProfilesApi - functional programming interface
 * @export
 */
export const IntegrationsWatermarkProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntegrationsWatermarkProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new watermarking profile. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
         * @summary Create a new watermarking profile
         * @param {WatermarkProfileCreateParams} watermarkProfileCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createanewwatermarkingprofile(watermarkProfileCreateParams: WatermarkProfileCreateParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatermarkProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createanewwatermarkingprofile(watermarkProfileCreateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a specific watermarking profile. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
         * @summary Delete a specific watermarking profile
         * @param {string} id Watermarking profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteaspecificwatermarkingprofile(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteaspecificwatermarkingprofile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all watermarking profiles. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
         * @summary Get all watermarking profiles
         * @param {Include} [include] Includes the available nodes in the response object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getallwatermarkingprofiles(include?: Include, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WatermarkProfileResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getallwatermarkingprofiles(include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific watermarking profile. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
         * @summary Get a specific watermarking profile
         * @param {string} id Watermarking profile ID
         * @param {Include} [include] Includes the available nodes in the response object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getaspecificwatermarkingprofile(id: string, include?: Include, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatermarkProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getaspecificwatermarkingprofile(id, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a specific watermarking profile. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
         * @summary Update a specific watermarking profile
         * @param {string} id Watermarking profile ID
         * @param {WatermarkProfileUpdateParams} watermarkProfileUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateaspecificwatermarkingprofile(id: string, watermarkProfileUpdateParams: WatermarkProfileUpdateParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateaspecificwatermarkingprofile(id, watermarkProfileUpdateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IntegrationsWatermarkProfilesApi - factory interface
 * @export
 */
export const IntegrationsWatermarkProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntegrationsWatermarkProfilesApiFp(configuration)
    return {
        /**
         * Creates a new watermarking profile. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
         * @summary Create a new watermarking profile
         * @param {WatermarkProfileCreateParams} watermarkProfileCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createanewwatermarkingprofile(watermarkProfileCreateParams: WatermarkProfileCreateParams, options?: any): AxiosPromise<WatermarkProfileResponse> {
            return localVarFp.createanewwatermarkingprofile(watermarkProfileCreateParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific watermarking profile. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
         * @summary Delete a specific watermarking profile
         * @param {string} id Watermarking profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteaspecificwatermarkingprofile(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteaspecificwatermarkingprofile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all watermarking profiles. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
         * @summary Get all watermarking profiles
         * @param {Include} [include] Includes the available nodes in the response object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getallwatermarkingprofiles(include?: Include, options?: any): AxiosPromise<Array<WatermarkProfileResponse>> {
            return localVarFp.getallwatermarkingprofiles(include, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific watermarking profile. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
         * @summary Get a specific watermarking profile
         * @param {string} id Watermarking profile ID
         * @param {Include} [include] Includes the available nodes in the response object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getaspecificwatermarkingprofile(id: string, include?: Include, options?: any): AxiosPromise<WatermarkProfileResponse> {
            return localVarFp.getaspecificwatermarkingprofile(id, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a specific watermarking profile. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
         * @summary Update a specific watermarking profile
         * @param {string} id Watermarking profile ID
         * @param {WatermarkProfileUpdateParams} watermarkProfileUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateaspecificwatermarkingprofile(id: string, watermarkProfileUpdateParams: WatermarkProfileUpdateParams, options?: any): AxiosPromise<void> {
            return localVarFp.updateaspecificwatermarkingprofile(id, watermarkProfileUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createanewwatermarkingprofile operation in IntegrationsWatermarkProfilesApi.
 * @export
 * @interface IntegrationsWatermarkProfilesApiCreateanewwatermarkingprofileRequest
 */
export interface IntegrationsWatermarkProfilesApiCreateanewwatermarkingprofileRequest {
    /**
     * 
     * @type {WatermarkProfileCreateParams}
     * @memberof IntegrationsWatermarkProfilesApiCreateanewwatermarkingprofile
     */
    readonly watermarkProfileCreateParams: WatermarkProfileCreateParams
}

/**
 * Request parameters for deleteaspecificwatermarkingprofile operation in IntegrationsWatermarkProfilesApi.
 * @export
 * @interface IntegrationsWatermarkProfilesApiDeleteaspecificwatermarkingprofileRequest
 */
export interface IntegrationsWatermarkProfilesApiDeleteaspecificwatermarkingprofileRequest {
    /**
     * Watermarking profile ID
     * @type {string}
     * @memberof IntegrationsWatermarkProfilesApiDeleteaspecificwatermarkingprofile
     */
    readonly id: string
}

/**
 * Request parameters for getallwatermarkingprofiles operation in IntegrationsWatermarkProfilesApi.
 * @export
 * @interface IntegrationsWatermarkProfilesApiGetallwatermarkingprofilesRequest
 */
export interface IntegrationsWatermarkProfilesApiGetallwatermarkingprofilesRequest {
    /**
     * Includes the available nodes in the response object
     * @type {Include}
     * @memberof IntegrationsWatermarkProfilesApiGetallwatermarkingprofiles
     */
    readonly include?: Include
}

/**
 * Request parameters for getaspecificwatermarkingprofile operation in IntegrationsWatermarkProfilesApi.
 * @export
 * @interface IntegrationsWatermarkProfilesApiGetaspecificwatermarkingprofileRequest
 */
export interface IntegrationsWatermarkProfilesApiGetaspecificwatermarkingprofileRequest {
    /**
     * Watermarking profile ID
     * @type {string}
     * @memberof IntegrationsWatermarkProfilesApiGetaspecificwatermarkingprofile
     */
    readonly id: string

    /**
     * Includes the available nodes in the response object
     * @type {Include}
     * @memberof IntegrationsWatermarkProfilesApiGetaspecificwatermarkingprofile
     */
    readonly include?: Include
}

/**
 * Request parameters for updateaspecificwatermarkingprofile operation in IntegrationsWatermarkProfilesApi.
 * @export
 * @interface IntegrationsWatermarkProfilesApiUpdateaspecificwatermarkingprofileRequest
 */
export interface IntegrationsWatermarkProfilesApiUpdateaspecificwatermarkingprofileRequest {
    /**
     * Watermarking profile ID
     * @type {string}
     * @memberof IntegrationsWatermarkProfilesApiUpdateaspecificwatermarkingprofile
     */
    readonly id: string

    /**
     * 
     * @type {WatermarkProfileUpdateParams}
     * @memberof IntegrationsWatermarkProfilesApiUpdateaspecificwatermarkingprofile
     */
    readonly watermarkProfileUpdateParams: WatermarkProfileUpdateParams
}

/**
 * IntegrationsWatermarkProfilesApi - object-oriented interface
 * @export
 * @class IntegrationsWatermarkProfilesApi
 * @extends {BaseAPI}
 */
export class IntegrationsWatermarkProfilesApi extends BaseAPI {
    /**
     * Creates a new watermarking profile. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
     * @summary Create a new watermarking profile
     * @param {IntegrationsWatermarkProfilesApiCreateanewwatermarkingprofileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsWatermarkProfilesApi
     */
    public createanewwatermarkingprofile(requestParameters: IntegrationsWatermarkProfilesApiCreateanewwatermarkingprofileRequest, options?: any) {
        return IntegrationsWatermarkProfilesApiFp(this.configuration).createanewwatermarkingprofile(requestParameters.watermarkProfileCreateParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific watermarking profile. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
     * @summary Delete a specific watermarking profile
     * @param {IntegrationsWatermarkProfilesApiDeleteaspecificwatermarkingprofileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsWatermarkProfilesApi
     */
    public deleteaspecificwatermarkingprofile(requestParameters: IntegrationsWatermarkProfilesApiDeleteaspecificwatermarkingprofileRequest, options?: any) {
        return IntegrationsWatermarkProfilesApiFp(this.configuration).deleteaspecificwatermarkingprofile(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all watermarking profiles. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
     * @summary Get all watermarking profiles
     * @param {IntegrationsWatermarkProfilesApiGetallwatermarkingprofilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsWatermarkProfilesApi
     */
    public getallwatermarkingprofiles(requestParameters: IntegrationsWatermarkProfilesApiGetallwatermarkingprofilesRequest = {}, options?: any) {
        return IntegrationsWatermarkProfilesApiFp(this.configuration).getallwatermarkingprofiles(requestParameters.include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific watermarking profile. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
     * @summary Get a specific watermarking profile
     * @param {IntegrationsWatermarkProfilesApiGetaspecificwatermarkingprofileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsWatermarkProfilesApi
     */
    public getaspecificwatermarkingprofile(requestParameters: IntegrationsWatermarkProfilesApiGetaspecificwatermarkingprofileRequest, options?: any) {
        return IntegrationsWatermarkProfilesApiFp(this.configuration).getaspecificwatermarkingprofile(requestParameters.id, requestParameters.include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a specific watermarking profile. Note: Errors for this endpoint may include specific error codes from Irdeto, such as 106-165, 1001-1014, and 3000. For more information, see https://help.dwm.irdeto.io/troubleshooting.html. 
     * @summary Update a specific watermarking profile
     * @param {IntegrationsWatermarkProfilesApiUpdateaspecificwatermarkingprofileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsWatermarkProfilesApi
     */
    public updateaspecificwatermarkingprofile(requestParameters: IntegrationsWatermarkProfilesApiUpdateaspecificwatermarkingprofileRequest, options?: any) {
        return IntegrationsWatermarkProfilesApiFp(this.configuration).updateaspecificwatermarkingprofile(requestParameters.id, requestParameters.watermarkProfileUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NodesApi - axios parameter creator
 * @export
 */
export const NodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new transfer node. User must be an organization admin.
         * @summary Create a New Node
         * @param {NodesParams} nodesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createaNewNode: async (nodesParams: NodesParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodesParams' is not null or undefined
            assertParamExists('createaNewNode', 'nodesParams', nodesParams)
            const localVarPath = `/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodesParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific transfer node, as specified by node ID. User must be an organization admin.
         * @summary Delete a Specific Node
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteaSpecificNode: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteaSpecificNode', 'id', id)
            const localVarPath = `/nodes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information about a specific transfer node.
         * @summary Get Information on a Specific Node
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInformationonaSpecificNode: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getInformationonaSpecificNode', 'id', id)
            const localVarPath = `/nodes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about all transfer nodes belonging to your organization.
         * @summary Get a Listing of All Nodes
         * @param {string} [accessKey] 
         * @param {string} [host] 
         * @param {string} [name] 
         * @param {string} [path] 
         * @param {string} [port] 
         * @param {string} [q] Full text search that will show transfer nodes with matching access_key, host, name, path, or port.
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getaListingofAllNodes: async (accessKey?: string, host?: string, name?: string, path?: string, port?: string, q?: string, status?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accessKey !== undefined) {
                localVarQueryParameter['access_key'] = accessKey;
            }

            if (host !== undefined) {
                localVarQueryParameter['host'] = host;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (port !== undefined) {
                localVarQueryParameter['port'] = port;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make changes to an existing transfer node. User must be an organization admin.
         * @summary Update a Node
         * @param {string} id 
         * @param {NodesParams} nodesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateaNode: async (id: string, nodesParams: NodesParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateaNode', 'id', id)
            // verify required parameter 'nodesParams' is not null or undefined
            assertParamExists('updateaNode', 'nodesParams', nodesParams)
            const localVarPath = `/nodes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodesParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodesApi - functional programming interface
 * @export
 */
export const NodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new transfer node. User must be an organization admin.
         * @summary Create a New Node
         * @param {NodesParams} nodesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createaNewNode(nodesParams: NodesParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createaNewNode(nodesParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a specific transfer node, as specified by node ID. User must be an organization admin.
         * @summary Delete a Specific Node
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteaSpecificNode(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteaSpecificNode(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information about a specific transfer node.
         * @summary Get Information on a Specific Node
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInformationonaSpecificNode(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInformationonaSpecificNode(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about all transfer nodes belonging to your organization.
         * @summary Get a Listing of All Nodes
         * @param {string} [accessKey] 
         * @param {string} [host] 
         * @param {string} [name] 
         * @param {string} [path] 
         * @param {string} [port] 
         * @param {string} [q] Full text search that will show transfer nodes with matching access_key, host, name, path, or port.
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getaListingofAllNodes(accessKey?: string, host?: string, name?: string, path?: string, port?: string, q?: string, status?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NodesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getaListingofAllNodes(accessKey, host, name, path, port, q, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Make changes to an existing transfer node. User must be an organization admin.
         * @summary Update a Node
         * @param {string} id 
         * @param {NodesParams} nodesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateaNode(id: string, nodesParams: NodesParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateaNode(id, nodesParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NodesApi - factory interface
 * @export
 */
export const NodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodesApiFp(configuration)
    return {
        /**
         * Create a new transfer node. User must be an organization admin.
         * @summary Create a New Node
         * @param {NodesParams} nodesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createaNewNode(nodesParams: NodesParams, options?: any): AxiosPromise<NodesResponse> {
            return localVarFp.createaNewNode(nodesParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific transfer node, as specified by node ID. User must be an organization admin.
         * @summary Delete a Specific Node
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteaSpecificNode(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteaSpecificNode(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information about a specific transfer node.
         * @summary Get Information on a Specific Node
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInformationonaSpecificNode(id: string, options?: any): AxiosPromise<NodesResponse> {
            return localVarFp.getInformationonaSpecificNode(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about all transfer nodes belonging to your organization.
         * @summary Get a Listing of All Nodes
         * @param {string} [accessKey] 
         * @param {string} [host] 
         * @param {string} [name] 
         * @param {string} [path] 
         * @param {string} [port] 
         * @param {string} [q] Full text search that will show transfer nodes with matching access_key, host, name, path, or port.
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getaListingofAllNodes(accessKey?: string, host?: string, name?: string, path?: string, port?: string, q?: string, status?: string, options?: any): AxiosPromise<Array<NodesResponse>> {
            return localVarFp.getaListingofAllNodes(accessKey, host, name, path, port, q, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Make changes to an existing transfer node. User must be an organization admin.
         * @summary Update a Node
         * @param {string} id 
         * @param {NodesParams} nodesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateaNode(id: string, nodesParams: NodesParams, options?: any): AxiosPromise<void> {
            return localVarFp.updateaNode(id, nodesParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createaNewNode operation in NodesApi.
 * @export
 * @interface NodesApiCreateaNewNodeRequest
 */
export interface NodesApiCreateaNewNodeRequest {
    /**
     * 
     * @type {NodesParams}
     * @memberof NodesApiCreateaNewNode
     */
    readonly nodesParams: NodesParams
}

/**
 * Request parameters for deleteaSpecificNode operation in NodesApi.
 * @export
 * @interface NodesApiDeleteaSpecificNodeRequest
 */
export interface NodesApiDeleteaSpecificNodeRequest {
    /**
     * 
     * @type {string}
     * @memberof NodesApiDeleteaSpecificNode
     */
    readonly id: string
}

/**
 * Request parameters for getInformationonaSpecificNode operation in NodesApi.
 * @export
 * @interface NodesApiGetInformationonaSpecificNodeRequest
 */
export interface NodesApiGetInformationonaSpecificNodeRequest {
    /**
     * 
     * @type {string}
     * @memberof NodesApiGetInformationonaSpecificNode
     */
    readonly id: string
}

/**
 * Request parameters for getaListingofAllNodes operation in NodesApi.
 * @export
 * @interface NodesApiGetaListingofAllNodesRequest
 */
export interface NodesApiGetaListingofAllNodesRequest {
    /**
     * 
     * @type {string}
     * @memberof NodesApiGetaListingofAllNodes
     */
    readonly accessKey?: string

    /**
     * 
     * @type {string}
     * @memberof NodesApiGetaListingofAllNodes
     */
    readonly host?: string

    /**
     * 
     * @type {string}
     * @memberof NodesApiGetaListingofAllNodes
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof NodesApiGetaListingofAllNodes
     */
    readonly path?: string

    /**
     * 
     * @type {string}
     * @memberof NodesApiGetaListingofAllNodes
     */
    readonly port?: string

    /**
     * Full text search that will show transfer nodes with matching access_key, host, name, path, or port.
     * @type {string}
     * @memberof NodesApiGetaListingofAllNodes
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof NodesApiGetaListingofAllNodes
     */
    readonly status?: string
}

/**
 * Request parameters for updateaNode operation in NodesApi.
 * @export
 * @interface NodesApiUpdateaNodeRequest
 */
export interface NodesApiUpdateaNodeRequest {
    /**
     * 
     * @type {string}
     * @memberof NodesApiUpdateaNode
     */
    readonly id: string

    /**
     * 
     * @type {NodesParams}
     * @memberof NodesApiUpdateaNode
     */
    readonly nodesParams: NodesParams
}

/**
 * NodesApi - object-oriented interface
 * @export
 * @class NodesApi
 * @extends {BaseAPI}
 */
export class NodesApi extends BaseAPI {
    /**
     * Create a new transfer node. User must be an organization admin.
     * @summary Create a New Node
     * @param {NodesApiCreateaNewNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public createaNewNode(requestParameters: NodesApiCreateaNewNodeRequest, options?: any) {
        return NodesApiFp(this.configuration).createaNewNode(requestParameters.nodesParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific transfer node, as specified by node ID. User must be an organization admin.
     * @summary Delete a Specific Node
     * @param {NodesApiDeleteaSpecificNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public deleteaSpecificNode(requestParameters: NodesApiDeleteaSpecificNodeRequest, options?: any) {
        return NodesApiFp(this.configuration).deleteaSpecificNode(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information about a specific transfer node.
     * @summary Get Information on a Specific Node
     * @param {NodesApiGetInformationonaSpecificNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getInformationonaSpecificNode(requestParameters: NodesApiGetInformationonaSpecificNodeRequest, options?: any) {
        return NodesApiFp(this.configuration).getInformationonaSpecificNode(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about all transfer nodes belonging to your organization.
     * @summary Get a Listing of All Nodes
     * @param {NodesApiGetaListingofAllNodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getaListingofAllNodes(requestParameters: NodesApiGetaListingofAllNodesRequest = {}, options?: any) {
        return NodesApiFp(this.configuration).getaListingofAllNodes(requestParameters.accessKey, requestParameters.host, requestParameters.name, requestParameters.path, requestParameters.port, requestParameters.q, requestParameters.status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Make changes to an existing transfer node. User must be an organization admin.
     * @summary Update a Node
     * @param {NodesApiUpdateaNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public updateaNode(requestParameters: NodesApiUpdateaNodeRequest, options?: any) {
        return NodesApiFp(this.configuration).updateaNode(requestParameters.id, requestParameters.nodesParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve information about your organization.
         * @summary Get Information About Your Organization
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInformationAboutYourOrganization: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getInformationAboutYourOrganization', 'id', id)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make changes to your organization. Must be an organization admin to access.
         * @summary Update Your Organization
         * @param {string} id 
         * @param {OrganizationsParams} organizationsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateYourOrganization: async (id: string, organizationsParams: OrganizationsParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateYourOrganization', 'id', id)
            // verify required parameter 'organizationsParams' is not null or undefined
            assertParamExists('updateYourOrganization', 'organizationsParams', organizationsParams)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationsParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve information about your organization.
         * @summary Get Information About Your Organization
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInformationAboutYourOrganization(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInformationAboutYourOrganization(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Make changes to your organization. Must be an organization admin to access.
         * @summary Update Your Organization
         * @param {string} id 
         * @param {OrganizationsParams} organizationsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateYourOrganization(id: string, organizationsParams: OrganizationsParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateYourOrganization(id, organizationsParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationsApiFp(configuration)
    return {
        /**
         * Retrieve information about your organization.
         * @summary Get Information About Your Organization
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInformationAboutYourOrganization(id: string, options?: any): AxiosPromise<OrganizationsResponse> {
            return localVarFp.getInformationAboutYourOrganization(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Make changes to your organization. Must be an organization admin to access.
         * @summary Update Your Organization
         * @param {string} id 
         * @param {OrganizationsParams} organizationsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateYourOrganization(id: string, organizationsParams: OrganizationsParams, options?: any): AxiosPromise<void> {
            return localVarFp.updateYourOrganization(id, organizationsParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getInformationAboutYourOrganization operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiGetInformationAboutYourOrganizationRequest
 */
export interface OrganizationsApiGetInformationAboutYourOrganizationRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationsApiGetInformationAboutYourOrganization
     */
    readonly id: string
}

/**
 * Request parameters for updateYourOrganization operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiUpdateYourOrganizationRequest
 */
export interface OrganizationsApiUpdateYourOrganizationRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationsApiUpdateYourOrganization
     */
    readonly id: string

    /**
     * 
     * @type {OrganizationsParams}
     * @memberof OrganizationsApiUpdateYourOrganization
     */
    readonly organizationsParams: OrganizationsParams
}

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * Retrieve information about your organization.
     * @summary Get Information About Your Organization
     * @param {OrganizationsApiGetInformationAboutYourOrganizationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getInformationAboutYourOrganization(requestParameters: OrganizationsApiGetInformationAboutYourOrganizationRequest, options?: any) {
        return OrganizationsApiFp(this.configuration).getInformationAboutYourOrganization(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Make changes to your organization. Must be an organization admin to access.
     * @summary Update Your Organization
     * @param {OrganizationsApiUpdateYourOrganizationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public updateYourOrganization(requestParameters: OrganizationsApiUpdateYourOrganizationRequest, options?: any) {
        return OrganizationsApiFp(this.configuration).updateYourOrganization(requestParameters.id, requestParameters.organizationsParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PackagesApi - axios parameter creator
 * @export
 */
export const PackagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Recipient can be an individual user, workspace, or a dropbox.
         * @summary add_package
         * @param {PackagesParams} packagesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPackage: async (packagesParams: PackagesParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'packagesParams' is not null or undefined
            assertParamExists('addPackage', 'packagesParams', packagesParams)
            const localVarPath = `/packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(packagesParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use package_id to delete the contents of a specific package. This action removes package contents permanently, but retains information on the package: sender, recipients, size, date, metadata if any, download history, and transfer specs like rate.
         * @summary delete_package
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePackage: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePackage', 'id', id)
            const localVarPath = `/packages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a specific package.
         * @summary get_package_by_id
         * @param {string} id 
         * @param {string} [embed] embed[]&#x3D;node (node from node_id) embed[]&#x3D;workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackageById: async (id: string, embed?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPackageById', 'id', id)
            const localVarPath = `/packages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (embed !== undefined) {
                localVarQueryParameter['embed[]'] = embed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about all packages or retrieve packages sent to me in a specific workspace, sent to me as individual (not as a member of a dropbox), that are not archived and not deleted if the user ID is included in the token sent with the call.
         * @summary get_packages
         * @param {boolean} [complete] 
         * @param {boolean} [completed] 
         * @param {string} [completedAt] 
         * @param {boolean} [deleted] 
         * @param {string} [dropboxId] 
         * @param {boolean} [expired] 
         * @param {boolean} [failed] 
         * @param {boolean} [draft] 
         * @param {string} [name] 
         * @param {string} [sentAt] 
         * @param {string} [createdAt] 
         * @param {string} [deletedAt] 
         * @param {number} [size] 
         * @param {string} [workspaceId] 
         * @param {string} [senderEmail] 
         * @param {string} [senderId] 
         * @param {string} [senderName] 
         * @param {string} [type] 
         * @param {boolean} [archived] 
         * @param {boolean} [read] 
         * @param {boolean} [received] 
         * @param {boolean} [sent] 
         * @param {string} [updatedAt] 
         * @param {boolean} [includeDraft] 
         * @param {boolean} [excludeDropboxPackages] 
         * @param {boolean} [hasContent] 
         * @param {string} [embed] embed[]&#x3D;node (node from node_id) embed[]&#x3D;workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackages: async (complete?: boolean, completed?: boolean, completedAt?: string, deleted?: boolean, dropboxId?: string, expired?: boolean, failed?: boolean, draft?: boolean, name?: string, sentAt?: string, createdAt?: string, deletedAt?: string, size?: number, workspaceId?: string, senderEmail?: string, senderId?: string, senderName?: string, type?: string, archived?: boolean, read?: boolean, received?: boolean, sent?: boolean, updatedAt?: string, includeDraft?: boolean, excludeDropboxPackages?: boolean, hasContent?: boolean, embed?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (complete !== undefined) {
                localVarQueryParameter['complete'] = complete;
            }

            if (completed !== undefined) {
                localVarQueryParameter['completed'] = completed;
            }

            if (completedAt !== undefined) {
                localVarQueryParameter['completed_at'] = (completedAt as any instanceof Date) ?
                    (completedAt as any).toISOString() :
                    completedAt;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (dropboxId !== undefined) {
                localVarQueryParameter['dropbox_id'] = dropboxId;
            }

            if (expired !== undefined) {
                localVarQueryParameter['expired'] = expired;
            }

            if (failed !== undefined) {
                localVarQueryParameter['failed'] = failed;
            }

            if (draft !== undefined) {
                localVarQueryParameter['draft'] = draft;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (sentAt !== undefined) {
                localVarQueryParameter['sent_at'] = (sentAt as any instanceof Date) ?
                    (sentAt as any).toISOString() :
                    sentAt;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = (createdAt as any instanceof Date) ?
                    (createdAt as any).toISOString() :
                    createdAt;
            }

            if (deletedAt !== undefined) {
                localVarQueryParameter['deleted_at'] = (deletedAt as any instanceof Date) ?
                    (deletedAt as any).toISOString() :
                    deletedAt;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (senderEmail !== undefined) {
                localVarQueryParameter['sender_email'] = senderEmail;
            }

            if (senderId !== undefined) {
                localVarQueryParameter['sender_id'] = senderId;
            }

            if (senderName !== undefined) {
                localVarQueryParameter['sender_name'] = senderName;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (read !== undefined) {
                localVarQueryParameter['read'] = read;
            }

            if (received !== undefined) {
                localVarQueryParameter['received'] = received;
            }

            if (sent !== undefined) {
                localVarQueryParameter['sent'] = sent;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = (updatedAt as any instanceof Date) ?
                    (updatedAt as any).toISOString() :
                    updatedAt;
            }

            if (includeDraft !== undefined) {
                localVarQueryParameter['include_draft'] = includeDraft;
            }

            if (excludeDropboxPackages !== undefined) {
                localVarQueryParameter['exclude_dropbox_packages'] = excludeDropboxPackages;
            }

            if (hasContent !== undefined) {
                localVarQueryParameter['has_content'] = hasContent;
            }

            if (embed !== undefined) {
                localVarQueryParameter['embed[]'] = embed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use the PUT method to mark the package \"sent=true\", including the proper number of transfers in the \"transfers_expected\" field, after the transfers have completed. The number of transfers expected depends on the number of discrete source locations of package contents.
         * @summary update_package
         * @param {string} id 
         * @param {PackagesParams} packagesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePackage: async (id: string, packagesParams: PackagesParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePackage', 'id', id)
            // verify required parameter 'packagesParams' is not null or undefined
            assertParamExists('updatePackage', 'packagesParams', packagesParams)
            const localVarPath = `/packages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(packagesParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PackagesApi - functional programming interface
 * @export
 */
export const PackagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PackagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Recipient can be an individual user, workspace, or a dropbox.
         * @summary add_package
         * @param {PackagesParams} packagesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPackage(packagesParams: PackagesParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPackage(packagesParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use package_id to delete the contents of a specific package. This action removes package contents permanently, but retains information on the package: sender, recipients, size, date, metadata if any, download history, and transfer specs like rate.
         * @summary delete_package
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePackage(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePackage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information on a specific package.
         * @summary get_package_by_id
         * @param {string} id 
         * @param {string} [embed] embed[]&#x3D;node (node from node_id) embed[]&#x3D;workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPackageById(id: string, embed?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPackageById(id, embed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about all packages or retrieve packages sent to me in a specific workspace, sent to me as individual (not as a member of a dropbox), that are not archived and not deleted if the user ID is included in the token sent with the call.
         * @summary get_packages
         * @param {boolean} [complete] 
         * @param {boolean} [completed] 
         * @param {string} [completedAt] 
         * @param {boolean} [deleted] 
         * @param {string} [dropboxId] 
         * @param {boolean} [expired] 
         * @param {boolean} [failed] 
         * @param {boolean} [draft] 
         * @param {string} [name] 
         * @param {string} [sentAt] 
         * @param {string} [createdAt] 
         * @param {string} [deletedAt] 
         * @param {number} [size] 
         * @param {string} [workspaceId] 
         * @param {string} [senderEmail] 
         * @param {string} [senderId] 
         * @param {string} [senderName] 
         * @param {string} [type] 
         * @param {boolean} [archived] 
         * @param {boolean} [read] 
         * @param {boolean} [received] 
         * @param {boolean} [sent] 
         * @param {string} [updatedAt] 
         * @param {boolean} [includeDraft] 
         * @param {boolean} [excludeDropboxPackages] 
         * @param {boolean} [hasContent] 
         * @param {string} [embed] embed[]&#x3D;node (node from node_id) embed[]&#x3D;workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPackages(complete?: boolean, completed?: boolean, completedAt?: string, deleted?: boolean, dropboxId?: string, expired?: boolean, failed?: boolean, draft?: boolean, name?: string, sentAt?: string, createdAt?: string, deletedAt?: string, size?: number, workspaceId?: string, senderEmail?: string, senderId?: string, senderName?: string, type?: string, archived?: boolean, read?: boolean, received?: boolean, sent?: boolean, updatedAt?: string, includeDraft?: boolean, excludeDropboxPackages?: boolean, hasContent?: boolean, embed?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PackagesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPackages(complete, completed, completedAt, deleted, dropboxId, expired, failed, draft, name, sentAt, createdAt, deletedAt, size, workspaceId, senderEmail, senderId, senderName, type, archived, read, received, sent, updatedAt, includeDraft, excludeDropboxPackages, hasContent, embed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use the PUT method to mark the package \"sent=true\", including the proper number of transfers in the \"transfers_expected\" field, after the transfers have completed. The number of transfers expected depends on the number of discrete source locations of package contents.
         * @summary update_package
         * @param {string} id 
         * @param {PackagesParams} packagesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePackage(id: string, packagesParams: PackagesParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePackage(id, packagesParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PackagesApi - factory interface
 * @export
 */
export const PackagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PackagesApiFp(configuration)
    return {
        /**
         * Recipient can be an individual user, workspace, or a dropbox.
         * @summary add_package
         * @param {PackagesParams} packagesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPackage(packagesParams: PackagesParams, options?: any): AxiosPromise<PackagesResponse> {
            return localVarFp.addPackage(packagesParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Use package_id to delete the contents of a specific package. This action removes package contents permanently, but retains information on the package: sender, recipients, size, date, metadata if any, download history, and transfer specs like rate.
         * @summary delete_package
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePackage(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePackage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on a specific package.
         * @summary get_package_by_id
         * @param {string} id 
         * @param {string} [embed] embed[]&#x3D;node (node from node_id) embed[]&#x3D;workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackageById(id: string, embed?: string, options?: any): AxiosPromise<PackagesResponse> {
            return localVarFp.getPackageById(id, embed, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about all packages or retrieve packages sent to me in a specific workspace, sent to me as individual (not as a member of a dropbox), that are not archived and not deleted if the user ID is included in the token sent with the call.
         * @summary get_packages
         * @param {boolean} [complete] 
         * @param {boolean} [completed] 
         * @param {string} [completedAt] 
         * @param {boolean} [deleted] 
         * @param {string} [dropboxId] 
         * @param {boolean} [expired] 
         * @param {boolean} [failed] 
         * @param {boolean} [draft] 
         * @param {string} [name] 
         * @param {string} [sentAt] 
         * @param {string} [createdAt] 
         * @param {string} [deletedAt] 
         * @param {number} [size] 
         * @param {string} [workspaceId] 
         * @param {string} [senderEmail] 
         * @param {string} [senderId] 
         * @param {string} [senderName] 
         * @param {string} [type] 
         * @param {boolean} [archived] 
         * @param {boolean} [read] 
         * @param {boolean} [received] 
         * @param {boolean} [sent] 
         * @param {string} [updatedAt] 
         * @param {boolean} [includeDraft] 
         * @param {boolean} [excludeDropboxPackages] 
         * @param {boolean} [hasContent] 
         * @param {string} [embed] embed[]&#x3D;node (node from node_id) embed[]&#x3D;workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackages(complete?: boolean, completed?: boolean, completedAt?: string, deleted?: boolean, dropboxId?: string, expired?: boolean, failed?: boolean, draft?: boolean, name?: string, sentAt?: string, createdAt?: string, deletedAt?: string, size?: number, workspaceId?: string, senderEmail?: string, senderId?: string, senderName?: string, type?: string, archived?: boolean, read?: boolean, received?: boolean, sent?: boolean, updatedAt?: string, includeDraft?: boolean, excludeDropboxPackages?: boolean, hasContent?: boolean, embed?: string, options?: any): AxiosPromise<Array<PackagesResponse>> {
            return localVarFp.getPackages(complete, completed, completedAt, deleted, dropboxId, expired, failed, draft, name, sentAt, createdAt, deletedAt, size, workspaceId, senderEmail, senderId, senderName, type, archived, read, received, sent, updatedAt, includeDraft, excludeDropboxPackages, hasContent, embed, options).then((request) => request(axios, basePath));
        },
        /**
         * Use the PUT method to mark the package \"sent=true\", including the proper number of transfers in the \"transfers_expected\" field, after the transfers have completed. The number of transfers expected depends on the number of discrete source locations of package contents.
         * @summary update_package
         * @param {string} id 
         * @param {PackagesParams} packagesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePackage(id: string, packagesParams: PackagesParams, options?: any): AxiosPromise<void> {
            return localVarFp.updatePackage(id, packagesParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addPackage operation in PackagesApi.
 * @export
 * @interface PackagesApiAddPackageRequest
 */
export interface PackagesApiAddPackageRequest {
    /**
     * 
     * @type {PackagesParams}
     * @memberof PackagesApiAddPackage
     */
    readonly packagesParams: PackagesParams
}

/**
 * Request parameters for deletePackage operation in PackagesApi.
 * @export
 * @interface PackagesApiDeletePackageRequest
 */
export interface PackagesApiDeletePackageRequest {
    /**
     * 
     * @type {string}
     * @memberof PackagesApiDeletePackage
     */
    readonly id: string
}

/**
 * Request parameters for getPackageById operation in PackagesApi.
 * @export
 * @interface PackagesApiGetPackageByIdRequest
 */
export interface PackagesApiGetPackageByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof PackagesApiGetPackageById
     */
    readonly id: string

    /**
     * embed[]&#x3D;node (node from node_id) embed[]&#x3D;workspace
     * @type {string}
     * @memberof PackagesApiGetPackageById
     */
    readonly embed?: string
}

/**
 * Request parameters for getPackages operation in PackagesApi.
 * @export
 * @interface PackagesApiGetPackagesRequest
 */
export interface PackagesApiGetPackagesRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PackagesApiGetPackages
     */
    readonly complete?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof PackagesApiGetPackages
     */
    readonly completed?: boolean

    /**
     * 
     * @type {string}
     * @memberof PackagesApiGetPackages
     */
    readonly completedAt?: string

    /**
     * 
     * @type {boolean}
     * @memberof PackagesApiGetPackages
     */
    readonly deleted?: boolean

    /**
     * 
     * @type {string}
     * @memberof PackagesApiGetPackages
     */
    readonly dropboxId?: string

    /**
     * 
     * @type {boolean}
     * @memberof PackagesApiGetPackages
     */
    readonly expired?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof PackagesApiGetPackages
     */
    readonly failed?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof PackagesApiGetPackages
     */
    readonly draft?: boolean

    /**
     * 
     * @type {string}
     * @memberof PackagesApiGetPackages
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof PackagesApiGetPackages
     */
    readonly sentAt?: string

    /**
     * 
     * @type {string}
     * @memberof PackagesApiGetPackages
     */
    readonly createdAt?: string

    /**
     * 
     * @type {string}
     * @memberof PackagesApiGetPackages
     */
    readonly deletedAt?: string

    /**
     * 
     * @type {number}
     * @memberof PackagesApiGetPackages
     */
    readonly size?: number

    /**
     * 
     * @type {string}
     * @memberof PackagesApiGetPackages
     */
    readonly workspaceId?: string

    /**
     * 
     * @type {string}
     * @memberof PackagesApiGetPackages
     */
    readonly senderEmail?: string

    /**
     * 
     * @type {string}
     * @memberof PackagesApiGetPackages
     */
    readonly senderId?: string

    /**
     * 
     * @type {string}
     * @memberof PackagesApiGetPackages
     */
    readonly senderName?: string

    /**
     * 
     * @type {string}
     * @memberof PackagesApiGetPackages
     */
    readonly type?: string

    /**
     * 
     * @type {boolean}
     * @memberof PackagesApiGetPackages
     */
    readonly archived?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof PackagesApiGetPackages
     */
    readonly read?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof PackagesApiGetPackages
     */
    readonly received?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof PackagesApiGetPackages
     */
    readonly sent?: boolean

    /**
     * 
     * @type {string}
     * @memberof PackagesApiGetPackages
     */
    readonly updatedAt?: string

    /**
     * 
     * @type {boolean}
     * @memberof PackagesApiGetPackages
     */
    readonly includeDraft?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof PackagesApiGetPackages
     */
    readonly excludeDropboxPackages?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof PackagesApiGetPackages
     */
    readonly hasContent?: boolean

    /**
     * embed[]&#x3D;node (node from node_id) embed[]&#x3D;workspace
     * @type {string}
     * @memberof PackagesApiGetPackages
     */
    readonly embed?: string
}

/**
 * Request parameters for updatePackage operation in PackagesApi.
 * @export
 * @interface PackagesApiUpdatePackageRequest
 */
export interface PackagesApiUpdatePackageRequest {
    /**
     * 
     * @type {string}
     * @memberof PackagesApiUpdatePackage
     */
    readonly id: string

    /**
     * 
     * @type {PackagesParams}
     * @memberof PackagesApiUpdatePackage
     */
    readonly packagesParams: PackagesParams
}

/**
 * PackagesApi - object-oriented interface
 * @export
 * @class PackagesApi
 * @extends {BaseAPI}
 */
export class PackagesApi extends BaseAPI {
    /**
     * Recipient can be an individual user, workspace, or a dropbox.
     * @summary add_package
     * @param {PackagesApiAddPackageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagesApi
     */
    public addPackage(requestParameters: PackagesApiAddPackageRequest, options?: any) {
        return PackagesApiFp(this.configuration).addPackage(requestParameters.packagesParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use package_id to delete the contents of a specific package. This action removes package contents permanently, but retains information on the package: sender, recipients, size, date, metadata if any, download history, and transfer specs like rate.
     * @summary delete_package
     * @param {PackagesApiDeletePackageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagesApi
     */
    public deletePackage(requestParameters: PackagesApiDeletePackageRequest, options?: any) {
        return PackagesApiFp(this.configuration).deletePackage(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on a specific package.
     * @summary get_package_by_id
     * @param {PackagesApiGetPackageByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagesApi
     */
    public getPackageById(requestParameters: PackagesApiGetPackageByIdRequest, options?: any) {
        return PackagesApiFp(this.configuration).getPackageById(requestParameters.id, requestParameters.embed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about all packages or retrieve packages sent to me in a specific workspace, sent to me as individual (not as a member of a dropbox), that are not archived and not deleted if the user ID is included in the token sent with the call.
     * @summary get_packages
     * @param {PackagesApiGetPackagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagesApi
     */
    public getPackages(requestParameters: PackagesApiGetPackagesRequest = {}, options?: any) {
        return PackagesApiFp(this.configuration).getPackages(requestParameters.complete, requestParameters.completed, requestParameters.completedAt, requestParameters.deleted, requestParameters.dropboxId, requestParameters.expired, requestParameters.failed, requestParameters.draft, requestParameters.name, requestParameters.sentAt, requestParameters.createdAt, requestParameters.deletedAt, requestParameters.size, requestParameters.workspaceId, requestParameters.senderEmail, requestParameters.senderId, requestParameters.senderName, requestParameters.type, requestParameters.archived, requestParameters.read, requestParameters.received, requestParameters.sent, requestParameters.updatedAt, requestParameters.includeDraft, requestParameters.excludeDropboxPackages, requestParameters.hasContent, requestParameters.embed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use the PUT method to mark the package \"sent=true\", including the proper number of transfers in the \"transfers_expected\" field, after the transfers have completed. The number of transfers expected depends on the number of discrete source locations of package contents.
     * @summary update_package
     * @param {PackagesApiUpdatePackageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagesApi
     */
    public updatePackage(requestParameters: PackagesApiUpdatePackageRequest, options?: any) {
        return PackagesApiFp(this.configuration).updatePackage(requestParameters.id, requestParameters.packagesParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsageReportsApi - axios parameter creator
 * @export
 */
export const UsageReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a listing of usage reports.
         * @summary get_usage_reports
         * @param {string} [nodeId] 
         * @param {string} [workspaceId] 
         * @param {string} [reportingPeriodStartedAt] 
         * @param {string} [reportingPeriodEndedAt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageReports: async (nodeId?: string, workspaceId?: string, reportingPeriodStartedAt?: string, reportingPeriodEndedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usage_reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nodeId !== undefined) {
                localVarQueryParameter['node_id'] = nodeId;
            }

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (reportingPeriodStartedAt !== undefined) {
                localVarQueryParameter['reporting_period_started_at'] = (reportingPeriodStartedAt as any instanceof Date) ?
                    (reportingPeriodStartedAt as any).toISOString() :
                    reportingPeriodStartedAt;
            }

            if (reportingPeriodEndedAt !== undefined) {
                localVarQueryParameter['reporting_period_ended_at'] = (reportingPeriodEndedAt as any instanceof Date) ?
                    (reportingPeriodEndedAt as any).toISOString() :
                    reportingPeriodEndedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsageReportsApi - functional programming interface
 * @export
 */
export const UsageReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsageReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a listing of usage reports.
         * @summary get_usage_reports
         * @param {string} [nodeId] 
         * @param {string} [workspaceId] 
         * @param {string} [reportingPeriodStartedAt] 
         * @param {string} [reportingPeriodEndedAt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsageReports(nodeId?: string, workspaceId?: string, reportingPeriodStartedAt?: string, reportingPeriodEndedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UsageReportsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageReports(nodeId, workspaceId, reportingPeriodStartedAt, reportingPeriodEndedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsageReportsApi - factory interface
 * @export
 */
export const UsageReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsageReportsApiFp(configuration)
    return {
        /**
         * Get a listing of usage reports.
         * @summary get_usage_reports
         * @param {string} [nodeId] 
         * @param {string} [workspaceId] 
         * @param {string} [reportingPeriodStartedAt] 
         * @param {string} [reportingPeriodEndedAt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageReports(nodeId?: string, workspaceId?: string, reportingPeriodStartedAt?: string, reportingPeriodEndedAt?: string, options?: any): AxiosPromise<Array<UsageReportsResponse>> {
            return localVarFp.getUsageReports(nodeId, workspaceId, reportingPeriodStartedAt, reportingPeriodEndedAt, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getUsageReports operation in UsageReportsApi.
 * @export
 * @interface UsageReportsApiGetUsageReportsRequest
 */
export interface UsageReportsApiGetUsageReportsRequest {
    /**
     * 
     * @type {string}
     * @memberof UsageReportsApiGetUsageReports
     */
    readonly nodeId?: string

    /**
     * 
     * @type {string}
     * @memberof UsageReportsApiGetUsageReports
     */
    readonly workspaceId?: string

    /**
     * 
     * @type {string}
     * @memberof UsageReportsApiGetUsageReports
     */
    readonly reportingPeriodStartedAt?: string

    /**
     * 
     * @type {string}
     * @memberof UsageReportsApiGetUsageReports
     */
    readonly reportingPeriodEndedAt?: string
}

/**
 * UsageReportsApi - object-oriented interface
 * @export
 * @class UsageReportsApi
 * @extends {BaseAPI}
 */
export class UsageReportsApi extends BaseAPI {
    /**
     * Get a listing of usage reports.
     * @summary get_usage_reports
     * @param {UsageReportsApiGetUsageReportsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageReportsApi
     */
    public getUsageReports(requestParameters: UsageReportsApiGetUsageReportsRequest = {}, options?: any) {
        return UsageReportsApiFp(this.configuration).getUsageReports(requestParameters.nodeId, requestParameters.workspaceId, requestParameters.reportingPeriodStartedAt, requestParameters.reportingPeriodEndedAt, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new user.
         * @summary add_user
         * @param {UsersParams} usersParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser: async (usersParams: UsersParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersParams' is not null or undefined
            assertParamExists('addUser', 'usersParams', usersParams)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific user.
         * @summary delete_user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Information on a specific user.
         * @summary get_user_by_id
         * @param {string} id 
         * @param {string} [embed] embed[]&#x3D;home_node embed[]&#x3D;organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (id: string, embed?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserById', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (embed !== undefined) {
                localVarQueryParameter['embed[]'] = embed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of information about all users.
         * @summary get_users
         * @param {string} [createdAt] 
         * @param {boolean} [deactivated] 
         * @param {string} [email] 
         * @param {string} [firstName] 
         * @param {string} [lastLoginAt] 
         * @param {string} [lastName] 
         * @param {string} [name] 
         * @param {boolean} [organizationAdmin] 
         * @param {string} [updatedAt] 
         * @param {string} [embed] embed[]&#x3D;home_node embed[]&#x3D;organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (createdAt?: string, deactivated?: boolean, email?: string, firstName?: string, lastLoginAt?: string, lastName?: string, name?: string, organizationAdmin?: boolean, updatedAt?: string, embed?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = (createdAt as any instanceof Date) ?
                    (createdAt as any).toISOString() :
                    createdAt;
            }

            if (deactivated !== undefined) {
                localVarQueryParameter['deactivated'] = deactivated;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['first_name'] = firstName;
            }

            if (lastLoginAt !== undefined) {
                localVarQueryParameter['last_login_at'] = (lastLoginAt as any instanceof Date) ?
                    (lastLoginAt as any).toISOString() :
                    lastLoginAt;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['last_name'] = lastName;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (organizationAdmin !== undefined) {
                localVarQueryParameter['organization_admin'] = organizationAdmin;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = (updatedAt as any instanceof Date) ?
                    (updatedAt as any).toISOString() :
                    updatedAt;
            }

            if (embed !== undefined) {
                localVarQueryParameter['embed[]'] = embed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make a change to an existing user; for example, make a user an administrator.
         * @summary update_user
         * @param {string} id 
         * @param {UsersParams} usersParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: string, usersParams: UsersParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            // verify required parameter 'usersParams' is not null or undefined
            assertParamExists('updateUser', 'usersParams', usersParams)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new user.
         * @summary add_user
         * @param {UsersParams} usersParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUser(usersParams: UsersParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUser(usersParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a specific user.
         * @summary delete_user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Information on a specific user.
         * @summary get_user_by_id
         * @param {string} id 
         * @param {string} [embed] embed[]&#x3D;home_node embed[]&#x3D;organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(id: string, embed?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(id, embed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of information about all users.
         * @summary get_users
         * @param {string} [createdAt] 
         * @param {boolean} [deactivated] 
         * @param {string} [email] 
         * @param {string} [firstName] 
         * @param {string} [lastLoginAt] 
         * @param {string} [lastName] 
         * @param {string} [name] 
         * @param {boolean} [organizationAdmin] 
         * @param {string} [updatedAt] 
         * @param {string} [embed] embed[]&#x3D;home_node embed[]&#x3D;organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(createdAt?: string, deactivated?: boolean, email?: string, firstName?: string, lastLoginAt?: string, lastName?: string, name?: string, organizationAdmin?: boolean, updatedAt?: string, embed?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UsersResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(createdAt, deactivated, email, firstName, lastLoginAt, lastName, name, organizationAdmin, updatedAt, embed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Make a change to an existing user; for example, make a user an administrator.
         * @summary update_user
         * @param {string} id 
         * @param {UsersParams} usersParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: string, usersParams: UsersParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, usersParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Create a new user.
         * @summary add_user
         * @param {UsersParams} usersParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser(usersParams: UsersParams, options?: any): AxiosPromise<UsersResponse> {
            return localVarFp.addUser(usersParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific user.
         * @summary delete_user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Information on a specific user.
         * @summary get_user_by_id
         * @param {string} id 
         * @param {string} [embed] embed[]&#x3D;home_node embed[]&#x3D;organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(id: string, embed?: string, options?: any): AxiosPromise<UsersResponse> {
            return localVarFp.getUserById(id, embed, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of information about all users.
         * @summary get_users
         * @param {string} [createdAt] 
         * @param {boolean} [deactivated] 
         * @param {string} [email] 
         * @param {string} [firstName] 
         * @param {string} [lastLoginAt] 
         * @param {string} [lastName] 
         * @param {string} [name] 
         * @param {boolean} [organizationAdmin] 
         * @param {string} [updatedAt] 
         * @param {string} [embed] embed[]&#x3D;home_node embed[]&#x3D;organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(createdAt?: string, deactivated?: boolean, email?: string, firstName?: string, lastLoginAt?: string, lastName?: string, name?: string, organizationAdmin?: boolean, updatedAt?: string, embed?: string, options?: any): AxiosPromise<Array<UsersResponse>> {
            return localVarFp.getUsers(createdAt, deactivated, email, firstName, lastLoginAt, lastName, name, organizationAdmin, updatedAt, embed, options).then((request) => request(axios, basePath));
        },
        /**
         * Make a change to an existing user; for example, make a user an administrator.
         * @summary update_user
         * @param {string} id 
         * @param {UsersParams} usersParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: string, usersParams: UsersParams, options?: any): AxiosPromise<void> {
            return localVarFp.updateUser(id, usersParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addUser operation in UsersApi.
 * @export
 * @interface UsersApiAddUserRequest
 */
export interface UsersApiAddUserRequest {
    /**
     * 
     * @type {UsersParams}
     * @memberof UsersApiAddUser
     */
    readonly usersParams: UsersParams
}

/**
 * Request parameters for deleteUser operation in UsersApi.
 * @export
 * @interface UsersApiDeleteUserRequest
 */
export interface UsersApiDeleteUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiDeleteUser
     */
    readonly id: string
}

/**
 * Request parameters for getUserById operation in UsersApi.
 * @export
 * @interface UsersApiGetUserByIdRequest
 */
export interface UsersApiGetUserByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiGetUserById
     */
    readonly id: string

    /**
     * embed[]&#x3D;home_node embed[]&#x3D;organization
     * @type {string}
     * @memberof UsersApiGetUserById
     */
    readonly embed?: string
}

/**
 * Request parameters for getUsers operation in UsersApi.
 * @export
 * @interface UsersApiGetUsersRequest
 */
export interface UsersApiGetUsersRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiGetUsers
     */
    readonly createdAt?: string

    /**
     * 
     * @type {boolean}
     * @memberof UsersApiGetUsers
     */
    readonly deactivated?: boolean

    /**
     * 
     * @type {string}
     * @memberof UsersApiGetUsers
     */
    readonly email?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiGetUsers
     */
    readonly firstName?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiGetUsers
     */
    readonly lastLoginAt?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiGetUsers
     */
    readonly lastName?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiGetUsers
     */
    readonly name?: string

    /**
     * 
     * @type {boolean}
     * @memberof UsersApiGetUsers
     */
    readonly organizationAdmin?: boolean

    /**
     * 
     * @type {string}
     * @memberof UsersApiGetUsers
     */
    readonly updatedAt?: string

    /**
     * embed[]&#x3D;home_node embed[]&#x3D;organization
     * @type {string}
     * @memberof UsersApiGetUsers
     */
    readonly embed?: string
}

/**
 * Request parameters for updateUser operation in UsersApi.
 * @export
 * @interface UsersApiUpdateUserRequest
 */
export interface UsersApiUpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiUpdateUser
     */
    readonly id: string

    /**
     * 
     * @type {UsersParams}
     * @memberof UsersApiUpdateUser
     */
    readonly usersParams: UsersParams
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Create a new user.
     * @summary add_user
     * @param {UsersApiAddUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addUser(requestParameters: UsersApiAddUserRequest, options?: any) {
        return UsersApiFp(this.configuration).addUser(requestParameters.usersParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific user.
     * @summary delete_user
     * @param {UsersApiDeleteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(requestParameters: UsersApiDeleteUserRequest, options?: any) {
        return UsersApiFp(this.configuration).deleteUser(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Information on a specific user.
     * @summary get_user_by_id
     * @param {UsersApiGetUserByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserById(requestParameters: UsersApiGetUserByIdRequest, options?: any) {
        return UsersApiFp(this.configuration).getUserById(requestParameters.id, requestParameters.embed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of information about all users.
     * @summary get_users
     * @param {UsersApiGetUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(requestParameters: UsersApiGetUsersRequest = {}, options?: any) {
        return UsersApiFp(this.configuration).getUsers(requestParameters.createdAt, requestParameters.deactivated, requestParameters.email, requestParameters.firstName, requestParameters.lastLoginAt, requestParameters.lastName, requestParameters.name, requestParameters.organizationAdmin, requestParameters.updatedAt, requestParameters.embed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Make a change to an existing user; for example, make a user an administrator.
     * @summary update_user
     * @param {UsersApiUpdateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(requestParameters: UsersApiUpdateUserRequest, options?: any) {
        return UsersApiFp(this.configuration).updateUser(requestParameters.id, requestParameters.usersParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkspaceMembershipsApi - axios parameter creator
 * @export
 */
export const WorkspaceMembershipsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a user as a member of this workspace.
         * @summary add_workspace_membership
         * @param {WorkspaceMembershipsParams} workspaceMembershipsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkspaceMembership: async (workspaceMembershipsParams: WorkspaceMembershipsParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceMembershipsParams' is not null or undefined
            assertParamExists('addWorkspaceMembership', 'workspaceMembershipsParams', workspaceMembershipsParams)
            const localVarPath = `/workspace_memberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceMembershipsParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a direct workspace membership. Note: If the user has indirect membership, through a group for example, the user still has access to the workspace.
         * @summary delete_workspace_membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceMembership: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWorkspaceMembership', 'id', id)
            const localVarPath = `/workspace_memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a specific membership.
         * @summary get_workspace_membership_by_id
         * @param {string} id 
         * @param {string} [embed] embed[]&#x3D;user (user object from user_id) embed[]&#x3D;node (node from node_id) embed[]&#x3D;group (from group_id) embed[]&#x3D;workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceMembershipById: async (id: string, embed?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkspaceMembershipById', 'id', id)
            const localVarPath = `/workspace_memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (embed !== undefined) {
                localVarQueryParameter['embed[]'] = embed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about the current members of a given workspace.
         * @summary get_workspace_memberships
         * @param {boolean} [canInviteByEmail] 
         * @param {string} [manager] 
         * @param {number} [workspaceId] 
         * @param {boolean} [storageAllowed] 
         * @param {string} [embed] embed[]&#x3D;user (user object from user_id) embed[]&#x3D;node (node from node_id) embed[]&#x3D;group (from group_id) embed[]&#x3D;workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceMemberships: async (canInviteByEmail?: boolean, manager?: string, workspaceId?: number, storageAllowed?: boolean, embed?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspace_memberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (canInviteByEmail !== undefined) {
                localVarQueryParameter['can_invite_by_email'] = canInviteByEmail;
            }

            if (manager !== undefined) {
                localVarQueryParameter['manager'] = manager;
            }

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (storageAllowed !== undefined) {
                localVarQueryParameter['storage_allowed'] = storageAllowed;
            }

            if (embed !== undefined) {
                localVarQueryParameter['embed[]'] = embed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make an existing workspace member a workspace manager.
         * @summary update_workspace_membership
         * @param {string} id 
         * @param {WorkspaceMembershipsUpdateParams} workspaceMembershipsUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceMembership: async (id: string, workspaceMembershipsUpdateParams: WorkspaceMembershipsUpdateParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateWorkspaceMembership', 'id', id)
            // verify required parameter 'workspaceMembershipsUpdateParams' is not null or undefined
            assertParamExists('updateWorkspaceMembership', 'workspaceMembershipsUpdateParams', workspaceMembershipsUpdateParams)
            const localVarPath = `/workspace_memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceMembershipsUpdateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspaceMembershipsApi - functional programming interface
 * @export
 */
export const WorkspaceMembershipsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspaceMembershipsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a user as a member of this workspace.
         * @summary add_workspace_membership
         * @param {WorkspaceMembershipsParams} workspaceMembershipsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addWorkspaceMembership(workspaceMembershipsParams: WorkspaceMembershipsParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceMembershipsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addWorkspaceMembership(workspaceMembershipsParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a direct workspace membership. Note: If the user has indirect membership, through a group for example, the user still has access to the workspace.
         * @summary delete_workspace_membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspaceMembership(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspaceMembership(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information on a specific membership.
         * @summary get_workspace_membership_by_id
         * @param {string} id 
         * @param {string} [embed] embed[]&#x3D;user (user object from user_id) embed[]&#x3D;node (node from node_id) embed[]&#x3D;group (from group_id) embed[]&#x3D;workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceMembershipById(id: string, embed?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceMembershipsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceMembershipById(id, embed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about the current members of a given workspace.
         * @summary get_workspace_memberships
         * @param {boolean} [canInviteByEmail] 
         * @param {string} [manager] 
         * @param {number} [workspaceId] 
         * @param {boolean} [storageAllowed] 
         * @param {string} [embed] embed[]&#x3D;user (user object from user_id) embed[]&#x3D;node (node from node_id) embed[]&#x3D;group (from group_id) embed[]&#x3D;workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceMemberships(canInviteByEmail?: boolean, manager?: string, workspaceId?: number, storageAllowed?: boolean, embed?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkspaceMembershipsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceMemberships(canInviteByEmail, manager, workspaceId, storageAllowed, embed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Make an existing workspace member a workspace manager.
         * @summary update_workspace_membership
         * @param {string} id 
         * @param {WorkspaceMembershipsUpdateParams} workspaceMembershipsUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspaceMembership(id: string, workspaceMembershipsUpdateParams: WorkspaceMembershipsUpdateParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspaceMembership(id, workspaceMembershipsUpdateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkspaceMembershipsApi - factory interface
 * @export
 */
export const WorkspaceMembershipsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspaceMembershipsApiFp(configuration)
    return {
        /**
         * Add a user as a member of this workspace.
         * @summary add_workspace_membership
         * @param {WorkspaceMembershipsParams} workspaceMembershipsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkspaceMembership(workspaceMembershipsParams: WorkspaceMembershipsParams, options?: any): AxiosPromise<WorkspaceMembershipsResponse> {
            return localVarFp.addWorkspaceMembership(workspaceMembershipsParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a direct workspace membership. Note: If the user has indirect membership, through a group for example, the user still has access to the workspace.
         * @summary delete_workspace_membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceMembership(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkspaceMembership(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on a specific membership.
         * @summary get_workspace_membership_by_id
         * @param {string} id 
         * @param {string} [embed] embed[]&#x3D;user (user object from user_id) embed[]&#x3D;node (node from node_id) embed[]&#x3D;group (from group_id) embed[]&#x3D;workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceMembershipById(id: string, embed?: string, options?: any): AxiosPromise<WorkspaceMembershipsResponse> {
            return localVarFp.getWorkspaceMembershipById(id, embed, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about the current members of a given workspace.
         * @summary get_workspace_memberships
         * @param {boolean} [canInviteByEmail] 
         * @param {string} [manager] 
         * @param {number} [workspaceId] 
         * @param {boolean} [storageAllowed] 
         * @param {string} [embed] embed[]&#x3D;user (user object from user_id) embed[]&#x3D;node (node from node_id) embed[]&#x3D;group (from group_id) embed[]&#x3D;workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceMemberships(canInviteByEmail?: boolean, manager?: string, workspaceId?: number, storageAllowed?: boolean, embed?: string, options?: any): AxiosPromise<Array<WorkspaceMembershipsResponse>> {
            return localVarFp.getWorkspaceMemberships(canInviteByEmail, manager, workspaceId, storageAllowed, embed, options).then((request) => request(axios, basePath));
        },
        /**
         * Make an existing workspace member a workspace manager.
         * @summary update_workspace_membership
         * @param {string} id 
         * @param {WorkspaceMembershipsUpdateParams} workspaceMembershipsUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceMembership(id: string, workspaceMembershipsUpdateParams: WorkspaceMembershipsUpdateParams, options?: any): AxiosPromise<void> {
            return localVarFp.updateWorkspaceMembership(id, workspaceMembershipsUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addWorkspaceMembership operation in WorkspaceMembershipsApi.
 * @export
 * @interface WorkspaceMembershipsApiAddWorkspaceMembershipRequest
 */
export interface WorkspaceMembershipsApiAddWorkspaceMembershipRequest {
    /**
     * 
     * @type {WorkspaceMembershipsParams}
     * @memberof WorkspaceMembershipsApiAddWorkspaceMembership
     */
    readonly workspaceMembershipsParams: WorkspaceMembershipsParams
}

/**
 * Request parameters for deleteWorkspaceMembership operation in WorkspaceMembershipsApi.
 * @export
 * @interface WorkspaceMembershipsApiDeleteWorkspaceMembershipRequest
 */
export interface WorkspaceMembershipsApiDeleteWorkspaceMembershipRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceMembershipsApiDeleteWorkspaceMembership
     */
    readonly id: string
}

/**
 * Request parameters for getWorkspaceMembershipById operation in WorkspaceMembershipsApi.
 * @export
 * @interface WorkspaceMembershipsApiGetWorkspaceMembershipByIdRequest
 */
export interface WorkspaceMembershipsApiGetWorkspaceMembershipByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceMembershipsApiGetWorkspaceMembershipById
     */
    readonly id: string

    /**
     * embed[]&#x3D;user (user object from user_id) embed[]&#x3D;node (node from node_id) embed[]&#x3D;group (from group_id) embed[]&#x3D;workspace
     * @type {string}
     * @memberof WorkspaceMembershipsApiGetWorkspaceMembershipById
     */
    readonly embed?: string
}

/**
 * Request parameters for getWorkspaceMemberships operation in WorkspaceMembershipsApi.
 * @export
 * @interface WorkspaceMembershipsApiGetWorkspaceMembershipsRequest
 */
export interface WorkspaceMembershipsApiGetWorkspaceMembershipsRequest {
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceMembershipsApiGetWorkspaceMemberships
     */
    readonly canInviteByEmail?: boolean

    /**
     * 
     * @type {string}
     * @memberof WorkspaceMembershipsApiGetWorkspaceMemberships
     */
    readonly manager?: string

    /**
     * 
     * @type {number}
     * @memberof WorkspaceMembershipsApiGetWorkspaceMemberships
     */
    readonly workspaceId?: number

    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceMembershipsApiGetWorkspaceMemberships
     */
    readonly storageAllowed?: boolean

    /**
     * embed[]&#x3D;user (user object from user_id) embed[]&#x3D;node (node from node_id) embed[]&#x3D;group (from group_id) embed[]&#x3D;workspace
     * @type {string}
     * @memberof WorkspaceMembershipsApiGetWorkspaceMemberships
     */
    readonly embed?: string
}

/**
 * Request parameters for updateWorkspaceMembership operation in WorkspaceMembershipsApi.
 * @export
 * @interface WorkspaceMembershipsApiUpdateWorkspaceMembershipRequest
 */
export interface WorkspaceMembershipsApiUpdateWorkspaceMembershipRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceMembershipsApiUpdateWorkspaceMembership
     */
    readonly id: string

    /**
     * 
     * @type {WorkspaceMembershipsUpdateParams}
     * @memberof WorkspaceMembershipsApiUpdateWorkspaceMembership
     */
    readonly workspaceMembershipsUpdateParams: WorkspaceMembershipsUpdateParams
}

/**
 * WorkspaceMembershipsApi - object-oriented interface
 * @export
 * @class WorkspaceMembershipsApi
 * @extends {BaseAPI}
 */
export class WorkspaceMembershipsApi extends BaseAPI {
    /**
     * Add a user as a member of this workspace.
     * @summary add_workspace_membership
     * @param {WorkspaceMembershipsApiAddWorkspaceMembershipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceMembershipsApi
     */
    public addWorkspaceMembership(requestParameters: WorkspaceMembershipsApiAddWorkspaceMembershipRequest, options?: any) {
        return WorkspaceMembershipsApiFp(this.configuration).addWorkspaceMembership(requestParameters.workspaceMembershipsParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a direct workspace membership. Note: If the user has indirect membership, through a group for example, the user still has access to the workspace.
     * @summary delete_workspace_membership
     * @param {WorkspaceMembershipsApiDeleteWorkspaceMembershipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceMembershipsApi
     */
    public deleteWorkspaceMembership(requestParameters: WorkspaceMembershipsApiDeleteWorkspaceMembershipRequest, options?: any) {
        return WorkspaceMembershipsApiFp(this.configuration).deleteWorkspaceMembership(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on a specific membership.
     * @summary get_workspace_membership_by_id
     * @param {WorkspaceMembershipsApiGetWorkspaceMembershipByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceMembershipsApi
     */
    public getWorkspaceMembershipById(requestParameters: WorkspaceMembershipsApiGetWorkspaceMembershipByIdRequest, options?: any) {
        return WorkspaceMembershipsApiFp(this.configuration).getWorkspaceMembershipById(requestParameters.id, requestParameters.embed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about the current members of a given workspace.
     * @summary get_workspace_memberships
     * @param {WorkspaceMembershipsApiGetWorkspaceMembershipsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceMembershipsApi
     */
    public getWorkspaceMemberships(requestParameters: WorkspaceMembershipsApiGetWorkspaceMembershipsRequest = {}, options?: any) {
        return WorkspaceMembershipsApiFp(this.configuration).getWorkspaceMemberships(requestParameters.canInviteByEmail, requestParameters.manager, requestParameters.workspaceId, requestParameters.storageAllowed, requestParameters.embed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Make an existing workspace member a workspace manager.
     * @summary update_workspace_membership
     * @param {WorkspaceMembershipsApiUpdateWorkspaceMembershipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceMembershipsApi
     */
    public updateWorkspaceMembership(requestParameters: WorkspaceMembershipsApiUpdateWorkspaceMembershipRequest, options?: any) {
        return WorkspaceMembershipsApiFp(this.configuration).updateWorkspaceMembership(requestParameters.id, requestParameters.workspaceMembershipsUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkspacesApi - axios parameter creator
 * @export
 */
export const WorkspacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new workspace.
         * @summary add_workspace
         * @param {WorkspacesParams} workspacesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkspace: async (workspacesParams: WorkspacesParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspacesParams' is not null or undefined
            assertParamExists('addWorkspace', 'workspacesParams', workspacesParams)
            const localVarPath = `/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspacesParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific workspace, specified by workspace ID.
         * @summary delete_workspace
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWorkspace', 'id', id)
            const localVarPath = `/workspaces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information on a specific workspace.
         * @summary get_workspace_by_id
         * @param {string} id 
         * @param {string} [embed] embed[]&#x3D;node (node from node_id) embed[]&#x3D;group (from group_id) embed[]&#x3D;organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceById: async (id: string, embed?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkspaceById', 'id', id)
            const localVarPath = `/workspaces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (embed !== undefined) {
                localVarQueryParameter['embed[]'] = embed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a listing of all configured workspaces.
         * @summary get_workspaces
         * @param {string} [createdAt] datetime
         * @param {string} [name] 
         * @param {number} [nodeId] 
         * @param {string} [updatedAt] 
         * @param {boolean} [manager] 
         * @param {string} [embed] embed[]&#x3D;node (node from node_id) embed[]&#x3D;group (from group_id) embed[]&#x3D;organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaces: async (createdAt?: string, name?: string, nodeId?: number, updatedAt?: string, manager?: boolean, embed?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = (createdAt as any instanceof Date) ?
                    (createdAt as any).toISOString() :
                    createdAt;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nodeId !== undefined) {
                localVarQueryParameter['node_id'] = nodeId;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = (updatedAt as any instanceof Date) ?
                    (updatedAt as any).toISOString() :
                    updatedAt;
            }

            if (manager !== undefined) {
                localVarQueryParameter['manager'] = manager;
            }

            if (embed !== undefined) {
                localVarQueryParameter['embed[]'] = embed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make changes to an existing workspace; for example, change collaboration settings.
         * @summary update_workspace
         * @param {string} id 
         * @param {WorkspacesParams} workspacesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace: async (id: string, workspacesParams: WorkspacesParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateWorkspace', 'id', id)
            // verify required parameter 'workspacesParams' is not null or undefined
            assertParamExists('updateWorkspace', 'workspacesParams', workspacesParams)
            const localVarPath = `/workspaces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspacesParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspacesApi - functional programming interface
 * @export
 */
export const WorkspacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspacesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new workspace.
         * @summary add_workspace
         * @param {WorkspacesParams} workspacesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addWorkspace(workspacesParams: WorkspacesParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspacesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addWorkspace(workspacesParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a specific workspace, specified by workspace ID.
         * @summary delete_workspace
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspace(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information on a specific workspace.
         * @summary get_workspace_by_id
         * @param {string} id 
         * @param {string} [embed] embed[]&#x3D;node (node from node_id) embed[]&#x3D;group (from group_id) embed[]&#x3D;organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceById(id: string, embed?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspacesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceById(id, embed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a listing of all configured workspaces.
         * @summary get_workspaces
         * @param {string} [createdAt] datetime
         * @param {string} [name] 
         * @param {number} [nodeId] 
         * @param {string} [updatedAt] 
         * @param {boolean} [manager] 
         * @param {string} [embed] embed[]&#x3D;node (node from node_id) embed[]&#x3D;group (from group_id) embed[]&#x3D;organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaces(createdAt?: string, name?: string, nodeId?: number, updatedAt?: string, manager?: boolean, embed?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkspacesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaces(createdAt, name, nodeId, updatedAt, manager, embed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Make changes to an existing workspace; for example, change collaboration settings.
         * @summary update_workspace
         * @param {string} id 
         * @param {WorkspacesParams} workspacesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspace(id: string, workspacesParams: WorkspacesParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspace(id, workspacesParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkspacesApi - factory interface
 * @export
 */
export const WorkspacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspacesApiFp(configuration)
    return {
        /**
         * Create a new workspace.
         * @summary add_workspace
         * @param {WorkspacesParams} workspacesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkspace(workspacesParams: WorkspacesParams, options?: any): AxiosPromise<WorkspacesResponse> {
            return localVarFp.addWorkspace(workspacesParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific workspace, specified by workspace ID.
         * @summary delete_workspace
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkspace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information on a specific workspace.
         * @summary get_workspace_by_id
         * @param {string} id 
         * @param {string} [embed] embed[]&#x3D;node (node from node_id) embed[]&#x3D;group (from group_id) embed[]&#x3D;organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceById(id: string, embed?: string, options?: any): AxiosPromise<WorkspacesResponse> {
            return localVarFp.getWorkspaceById(id, embed, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a listing of all configured workspaces.
         * @summary get_workspaces
         * @param {string} [createdAt] datetime
         * @param {string} [name] 
         * @param {number} [nodeId] 
         * @param {string} [updatedAt] 
         * @param {boolean} [manager] 
         * @param {string} [embed] embed[]&#x3D;node (node from node_id) embed[]&#x3D;group (from group_id) embed[]&#x3D;organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaces(createdAt?: string, name?: string, nodeId?: number, updatedAt?: string, manager?: boolean, embed?: string, options?: any): AxiosPromise<Array<WorkspacesResponse>> {
            return localVarFp.getWorkspaces(createdAt, name, nodeId, updatedAt, manager, embed, options).then((request) => request(axios, basePath));
        },
        /**
         * Make changes to an existing workspace; for example, change collaboration settings.
         * @summary update_workspace
         * @param {string} id 
         * @param {WorkspacesParams} workspacesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace(id: string, workspacesParams: WorkspacesParams, options?: any): AxiosPromise<void> {
            return localVarFp.updateWorkspace(id, workspacesParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addWorkspace operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiAddWorkspaceRequest
 */
export interface WorkspacesApiAddWorkspaceRequest {
    /**
     * 
     * @type {WorkspacesParams}
     * @memberof WorkspacesApiAddWorkspace
     */
    readonly workspacesParams: WorkspacesParams
}

/**
 * Request parameters for deleteWorkspace operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiDeleteWorkspaceRequest
 */
export interface WorkspacesApiDeleteWorkspaceRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiDeleteWorkspace
     */
    readonly id: string
}

/**
 * Request parameters for getWorkspaceById operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiGetWorkspaceByIdRequest
 */
export interface WorkspacesApiGetWorkspaceByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiGetWorkspaceById
     */
    readonly id: string

    /**
     * embed[]&#x3D;node (node from node_id) embed[]&#x3D;group (from group_id) embed[]&#x3D;organization
     * @type {string}
     * @memberof WorkspacesApiGetWorkspaceById
     */
    readonly embed?: string
}

/**
 * Request parameters for getWorkspaces operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiGetWorkspacesRequest
 */
export interface WorkspacesApiGetWorkspacesRequest {
    /**
     * datetime
     * @type {string}
     * @memberof WorkspacesApiGetWorkspaces
     */
    readonly createdAt?: string

    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiGetWorkspaces
     */
    readonly name?: string

    /**
     * 
     * @type {number}
     * @memberof WorkspacesApiGetWorkspaces
     */
    readonly nodeId?: number

    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiGetWorkspaces
     */
    readonly updatedAt?: string

    /**
     * 
     * @type {boolean}
     * @memberof WorkspacesApiGetWorkspaces
     */
    readonly manager?: boolean

    /**
     * embed[]&#x3D;node (node from node_id) embed[]&#x3D;group (from group_id) embed[]&#x3D;organization
     * @type {string}
     * @memberof WorkspacesApiGetWorkspaces
     */
    readonly embed?: string
}

/**
 * Request parameters for updateWorkspace operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiUpdateWorkspaceRequest
 */
export interface WorkspacesApiUpdateWorkspaceRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiUpdateWorkspace
     */
    readonly id: string

    /**
     * 
     * @type {WorkspacesParams}
     * @memberof WorkspacesApiUpdateWorkspace
     */
    readonly workspacesParams: WorkspacesParams
}

/**
 * WorkspacesApi - object-oriented interface
 * @export
 * @class WorkspacesApi
 * @extends {BaseAPI}
 */
export class WorkspacesApi extends BaseAPI {
    /**
     * Create a new workspace.
     * @summary add_workspace
     * @param {WorkspacesApiAddWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public addWorkspace(requestParameters: WorkspacesApiAddWorkspaceRequest, options?: any) {
        return WorkspacesApiFp(this.configuration).addWorkspace(requestParameters.workspacesParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific workspace, specified by workspace ID.
     * @summary delete_workspace
     * @param {WorkspacesApiDeleteWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public deleteWorkspace(requestParameters: WorkspacesApiDeleteWorkspaceRequest, options?: any) {
        return WorkspacesApiFp(this.configuration).deleteWorkspace(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information on a specific workspace.
     * @summary get_workspace_by_id
     * @param {WorkspacesApiGetWorkspaceByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public getWorkspaceById(requestParameters: WorkspacesApiGetWorkspaceByIdRequest, options?: any) {
        return WorkspacesApiFp(this.configuration).getWorkspaceById(requestParameters.id, requestParameters.embed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a listing of all configured workspaces.
     * @summary get_workspaces
     * @param {WorkspacesApiGetWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public getWorkspaces(requestParameters: WorkspacesApiGetWorkspacesRequest = {}, options?: any) {
        return WorkspacesApiFp(this.configuration).getWorkspaces(requestParameters.createdAt, requestParameters.name, requestParameters.nodeId, requestParameters.updatedAt, requestParameters.manager, requestParameters.embed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Make changes to an existing workspace; for example, change collaboration settings.
     * @summary update_workspace
     * @param {WorkspacesApiUpdateWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public updateWorkspace(requestParameters: WorkspacesApiUpdateWorkspaceRequest, options?: any) {
        return WorkspacesApiFp(this.configuration).updateWorkspace(requestParameters.id, requestParameters.workspacesParams, options).then((request) => request(this.axios, this.basePath));
    }
}


